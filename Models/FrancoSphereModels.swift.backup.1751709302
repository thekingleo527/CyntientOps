//
//  FrancoSphereModels.swift
//  FrancoSphere
//
//  ðŸŽ¯ SINGLE SOURCE OF TRUTH - COMPLETE TYPE DEFINITIONS
//  âœ… All types properly nested under FrancoSphere enum
//  âœ… No circular references or duplicates
//  âœ… Complete type coverage for entire codebase
//  âœ… Swift 5.9 / iOS 17 compatible
//

import Foundation
import CoreLocation
import SwiftUI

// MARK: - FrancoSphere Namespace - Complete Definition
public enum FrancoSphere {
    
    // MARK: - Core Geographic Models
    public struct NamedCoordinate: Identifiable, Codable, Equatable {
        public let id: String
        public let name: String
        public let latitude: Double
        public let longitude: Double
        public let address: String?
        public let imageAssetName: String?
        
        public var coordinate: CLLocationCoordinate2D {
            CLLocationCoordinate2D(latitude: latitude, longitude: longitude)
        }
        
        public init(id: String, name: String, coordinate: CLLocationCoordinate2D, address: String? = nil, imageAssetName: String? = nil) {
            self.id = id
            self.name = name
            self.latitude = coordinate.latitude
            self.longitude = coordinate.longitude
            self.address = address
            self.imageAssetName = imageAssetName
        }
        
        public static func == (lhs: NamedCoordinate, rhs: NamedCoordinate) -> Bool {
            lhs.id == rhs.id
        }
    }
    
    // MARK: - Building Models
    public enum BuildingTab: String, CaseIterable, Codable {
        case overview = "Overview"
        case tasks = "Tasks"
        case inventory = "Inventory"
        case insights = "Insights"
    }
    
    public enum BuildingStatus: String, CaseIterable, Codable {
        case active = "Active"
        case maintenance = "Maintenance"
        case inspection = "Inspection"
        case emergency = "Emergency"
        
        public var color: Color {
            switch self {
            case .active: return .green
            case .maintenance: return .orange
            case .inspection: return .blue
            case .emergency: return .red
            }
        }
    }
    
    // MARK: - User & Worker Models
    public enum UserRole: String, Codable, CaseIterable {
        case admin
        case supervisor
        case worker
        case client
        
        public var displayName: String {
            switch self {
            case .admin: return "Administrator"
            case .supervisor: return "Supervisor"
            case .worker: return "Worker"
            case .client: return "Client"
            }
        }
    }
    
    public enum WorkerSkill: String, CaseIterable, Codable {
        case basic = "Basic Cleaning"
        case maintenance = "General Maintenance"
        case electrical = "Electrical"
        case plumbing = "Plumbing"
        case hvac = "HVAC"
        case painting = "Painting"
        case carpentry = "Carpentry"
        case landscaping = "Landscaping"
        case security = "Security"
        case specialized = "Specialized"
        
        public var category: WorkerSkillCategory {
            switch self {
            case .basic: return .cleaning
            case .maintenance: return .maintenance
            case .electrical, .plumbing, .hvac: return .technical
            case .painting, .carpentry: return .construction
            case .landscaping: return .outdoor
            case .security: return .safety
            case .specialized: return .specialized
            }
        }
    }
    
    public enum WorkerSkillCategory: String, Codable, CaseIterable {
        case cleaning = "Cleaning"
        case maintenance = "Maintenance"
        case technical = "Technical"
        case construction = "Construction"
        case outdoor = "Outdoor"
        case safety = "Safety"
        case specialized = "Specialized"
    }
    
    public struct WorkerProfile: Identifiable, Codable {
        public let id: String
        public let name: String
        public let email: String
        public let role: UserRole
        public var skills: [WorkerSkill]
        public var assignedBuildings: [String]
        public var skillLevel: WorkerSkill?
        public var isActive: Bool
        public var phone: String?
        public var hourlyRate: Double?
        public var profileImagePath: String?
        public var address: String?
        public var emergencyContact: String?
        public var notes: String?
        
        public init(id: String, name: String, email: String, role: UserRole, skills: [WorkerSkill] = [], assignedBuildings: [String] = [], skillLevel: WorkerSkill? = nil, isActive: Bool = true, phone: String? = nil, hourlyRate: Double? = nil, profileImagePath: String? = nil, address: String? = nil, emergencyContact: String? = nil, notes: String? = nil) {
            self.id = id
            self.name = name
            self.email = email
            self.role = role
            self.skills = skills
            self.assignedBuildings = assignedBuildings
            self.skillLevel = skillLevel
            self.isActive = isActive
            self.phone = phone
            self.hourlyRate = hourlyRate
            self.profileImagePath = profileImagePath
            self.address = address
            self.emergencyContact = emergencyContact
            self.notes = notes
        }
    }
    
    public struct WorkerAssignment: Identifiable, Codable {
        public let id: String
        public let workerId: String
        public let buildingId: String
        public let assignedDate: Date
        public let isActive: Bool
        
        public init(id: String, workerId: String, buildingId: String, assignedDate: Date, isActive: Bool = true) {
            self.id = id
            self.workerId = workerId
            self.buildingId = buildingId
            self.assignedDate = assignedDate
            self.isActive = isActive
        }
    }
    
    // MARK: - Task Models
    public enum TaskCategory: String, CaseIterable, Codable {
        case cleaning = "Cleaning"
        case maintenance = "Maintenance"
        case inspection = "Inspection"
        case repair = "Repair"
        case security = "Security"
        case landscaping = "Landscaping"
        case administrative = "Administrative"
        case emergency = "Emergency"
        
        public var color: Color {
            switch self {
            case .cleaning: return .blue
            case .maintenance: return .orange
            case .inspection: return .purple
            case .repair: return .red
            case .security: return .gray
            case .landscaping: return .green
            case .administrative: return .indigo
            case .emergency: return .red
            }
        }
        
        public var icon: String {
            switch self {
            case .cleaning: return "sparkles"
            case .maintenance: return "wrench.and.screwdriver"
            case .inspection: return "magnifyingglass"
            case .repair: return "hammer"
            case .security: return "shield"
            case .landscaping: return "leaf"
            case .administrative: return "doc.text"
            case .emergency: return "exclamationmark.triangle"
            }
        }
    }
    
    public enum TaskUrgency: String, CaseIterable, Codable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case critical = "Critical"
        
        public var color: Color {
            switch self {
            case .low: return .green
            case .medium: return .yellow
            case .high: return .orange
            case .critical: return .red
            }
        }
        
        public var priority: Int {
            switch self {
            case .low: return 1
            case .medium: return 2
            case .high: return 3
            case .critical: return 4
            }
        }
    }
    
    public enum TaskRecurrence: String, CaseIterable, Codable {
        case none = "None"
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
        case quarterly = "Quarterly"
        case annually = "Annually"
        case custom = "Custom"
    }
    
    public enum VerificationStatus: String, Codable, CaseIterable {
        case pending = "Pending"
        case verified = "Verified"
        case rejected = "Rejected"
        case requiresReview = "Requires Review"
        
        public var color: Color {
            switch self {
            case .pending: return .yellow
            case .verified: return .green
            case .rejected: return .red
            case .requiresReview: return .orange
            }
        }
    }
    
    public struct MaintenanceTask: Identifiable, Codable {
        public let id: String
        public let title: String
        public let description: String
        public let category: TaskCategory
        public let urgency: TaskUrgency
        public let buildingId: String
        public let assignedTo: String?
        public let dueDate: Date?
        public let estimatedDuration: TimeInterval
        public let recurrence: TaskRecurrence
        public let requiredSkills: [WorkerSkill]
        public let isCompleted: Bool
        public let completedDate: Date?
        public let completedBy: String?
        public let notes: String?
        public let photoPaths: [String]
        public let verificationStatus: VerificationStatus
        public let createdDate: Date
        public let lastModified: Date
        
        public init(id: String, title: String, description: String, category: TaskCategory, urgency: TaskUrgency, buildingId: String, assignedTo: String? = nil, dueDate: Date? = nil, estimatedDuration: TimeInterval = 1800, recurrence: TaskRecurrence = .none, requiredSkills: [WorkerSkill] = [], isCompleted: Bool = false, completedDate: Date? = nil, completedBy: String? = nil, notes: String? = nil, photoPaths: [String] = [], verificationStatus: VerificationStatus = .pending, createdDate: Date = Date(), lastModified: Date = Date()) {
            self.id = id
            self.title = title
            self.description = description
            self.category = category
            self.urgency = urgency
            self.buildingId = buildingId
            self.assignedTo = assignedTo
            self.dueDate = dueDate
            self.estimatedDuration = estimatedDuration
            self.recurrence = recurrence
            self.requiredSkills = requiredSkills
            self.isCompleted = isCompleted
            self.completedDate = completedDate
            self.completedBy = completedBy
            self.notes = notes
            self.photoPaths = photoPaths
            self.verificationStatus = verificationStatus
            self.createdDate = createdDate
            self.lastModified = lastModified
        }
    }
    
    public struct TaskCompletionInfo: Codable {
        public let taskId: String
        public let completedBy: String
        public let completedDate: Date
        public let notes: String?
        public let photoPaths: [String]
        public let verificationStatus: VerificationStatus
        
        public init(taskId: String, completedBy: String, completedDate: Date, notes: String? = nil, photoPaths: [String] = [], verificationStatus: VerificationStatus = .pending) {
            self.taskId = taskId
            self.completedBy = completedBy
            self.completedDate = completedDate
            self.notes = notes
            self.photoPaths = photoPaths
            self.verificationStatus = verificationStatus
        }
    }
    
    public struct TaskEvidence: Codable {
        public let photos: [Data]
        public let timestamp: Date
        public let location: CLLocation?
        public let notes: String?
        
        public init(photos: [Data], timestamp: Date, location: CLLocation? = nil, notes: String? = nil) {
            self.photos = photos
            self.timestamp = timestamp
            self.location = location
            self.notes = notes
        }
    }
    
    public struct TaskProgress: Codable {
        public let completed: Int
        public let total: Int
        public let remaining: Int
        public let percentage: Double
        public let overdueTasks: Int
        
        public init(completed: Int, total: Int, remaining: Int, percentage: Double, overdueTasks: Int) {
            self.completed = completed
            self.total = total
            self.remaining = remaining
            self.percentage = percentage
            self.overdueTasks = overdueTasks
        }
    }
    
    // MARK: - Inventory Models
    public enum InventoryCategory: String, CaseIterable, Codable {
        case cleaning = "Cleaning Supplies"
        case tools = "Tools & Equipment"
        case safety = "Safety Equipment"
        case plumbing = "Plumbing"
        case electrical = "Electrical"
        case paint = "Paint & Finishes"
        case hardware = "Hardware"
        case seasonal = "Seasonal"
        
        public var color: Color {
            switch self {
            case .cleaning: return .blue
            case .tools: return .gray
            case .safety: return .red
            case .plumbing: return .cyan
            case .electrical: return .yellow
            case .paint: return .purple
            case .hardware: return .brown
            case .seasonal: return .green
            }
        }
        
        public var icon: String {
            switch self {
            case .cleaning: return "sparkles"
            case .tools: return "wrench.and.screwdriver"
            case .safety: return "shield"
            case .plumbing: return "drop"
            case .electrical: return "bolt"
            case .paint: return "paintbrush"
            case .hardware: return "screw"
            case .seasonal: return "leaf"
            }
        }
    }
    
    public enum RestockStatus: String, Codable, CaseIterable {
        case inStock = "In Stock"
        case lowStock = "Low Stock"
        case outOfStock = "Out of Stock"
        case ordered = "Ordered"
        
        public var color: Color {
            switch self {
            case .inStock: return .green
            case .lowStock: return .yellow
            case .outOfStock: return .red
            case .ordered: return .blue
            }
        }
    }
    
    public struct InventoryItem: Identifiable, Codable {
        public let id: String
        public let name: String
        public let category: InventoryCategory
        public let quantity: Int
        public let unit: String
        public let minimumQuantity: Int
        public let buildingId: String
        public let location: String
        public let restockStatus: RestockStatus
        public let lastRestocked: Date?
        public let cost: Double?
        public let supplier: String?
        public let notes: String?
        
        public init(id: String, name: String, category: InventoryCategory, quantity: Int, unit: String, minimumQuantity: Int, buildingId: String, location: String, restockStatus: RestockStatus, lastRestocked: Date? = nil, cost: Double? = nil, supplier: String? = nil, notes: String? = nil) {
            self.id = id
            self.name = name
            self.category = category
            self.quantity = quantity
            self.unit = unit
            self.minimumQuantity = minimumQuantity
            self.buildingId = buildingId
            self.location = location
            self.restockStatus = restockStatus
            self.lastRestocked = lastRestocked
            self.cost = cost
            self.supplier = supplier
            self.notes = notes
        }
    }
    
    // MARK: - Weather Models
    public enum WeatherCondition: String, Codable, CaseIterable {
        case clear = "Clear"
        case cloudy = "Cloudy"
        case rain = "Rain"
        case snow = "Snow"
        case storm = "Storm"
        case fog = "Fog"
        case windy = "Windy"
        
        public var icon: String {
            switch self {
            case .clear: return "sun.max.fill"
            case .cloudy: return "cloud.fill"
            case .rain: return "cloud.rain.fill"
            case .snow: return "cloud.snow.fill"
            case .storm: return "cloud.bolt.fill"
            case .fog: return "cloud.fog.fill"
            case .windy: return "wind"
            }
        }
        
        public var color: Color {
            switch self {
            case .clear: return .yellow
            case .cloudy: return .gray
            case .rain: return .blue
            case .snow: return .white
            case .storm: return .purple
            case .fog: return .gray
            case .windy: return .cyan
            }
        }
    }
    
    public struct WeatherData: Codable {
        public let date: Date
        public let temperature: Double
        public let feelsLike: Double
        public let humidity: Int
        public let windSpeed: Double
        public let windDirection: Int
        public let precipitation: Double
        public let snow: Double
        public let visibility: Double
        public let pressure: Double
        public let condition: WeatherCondition
        public let icon: String
        
        public init(date: Date, temperature: Double, feelsLike: Double, humidity: Int, windSpeed: Double, windDirection: Int, precipitation: Double, snow: Double, visibility: Double, pressure: Double, condition: WeatherCondition, icon: String) {
            self.date = date
            self.temperature = temperature
            self.feelsLike = feelsLike
            self.humidity = humidity
            self.windSpeed = windSpeed
            self.windDirection = windDirection
            self.precipitation = precipitation
            self.snow = snow
            self.visibility = visibility
            self.pressure = pressure
            self.condition = condition
            self.icon = icon
        }
    }
    
    // MARK: - AI & Context Models
    public enum AIScenario: String, Codable, CaseIterable {
        case routineIncomplete = "routineIncomplete"
        case pendingTasks = "pendingTasks"
        case missingPhoto = "missingPhoto"
        case clockOutReminder = "clockOutReminder"
        case weatherAlert = "weatherAlert"
        case buildingArrival = "buildingArrival"
        case taskCompletion = "taskCompletion"
        case inventoryLow = "inventoryLow"
        
        public var displayName: String {
            switch self {
            case .routineIncomplete: return "Routine Incomplete"
            case .pendingTasks: return "Pending Tasks"
            case .missingPhoto: return "Missing Photo"
            case .clockOutReminder: return "Clock Out Reminder"
            case .weatherAlert: return "Weather Alert"
            case .buildingArrival: return "Building Arrival"
            case .taskCompletion: return "Task Completion"
            case .inventoryLow: return "Low Inventory"
            }
        }
        
        public var icon: String {
            switch self {
            case .routineIncomplete: return "checklist"
            case .pendingTasks: return "list.bullet.rectangle"
            case .missingPhoto: return "camera.fill"
            case .clockOutReminder: return "clock.badge.checkmark.fill"
            case .weatherAlert: return "cloud.sun.fill"
            case .buildingArrival: return "building.2.circle.fill"
            case .taskCompletion: return "checkmark.circle.fill"
            case .inventoryLow: return "shippingbox.circle.fill"
            }
        }
    }
    
    public struct AISuggestion: Identifiable, Codable {
        public let id: String
        public let title: String
        public let description: String
        public let priority: Int
        public let scenario: AIScenario
        public let suggestedActions: [String]
        public let confidence: Double
        
        public init(id: String, title: String, description: String, priority: Int, scenario: AIScenario, suggestedActions: [String], confidence: Double) {
            self.id = id
            self.title = title
            self.description = description
            self.priority = priority
            self.scenario = scenario
            self.suggestedActions = suggestedActions
            self.confidence = confidence
        }
    }
    
    // MARK: - Contextual Task Model (Missing Key Type!)
    public struct ContextualTask: Identifiable, Codable {
        public let id: String
        public let maintenanceTask: MaintenanceTask
        public let contextualInfo: String?
        public let estimatedTime: TimeInterval
        public let weatherImpact: String?
        public let requiredTools: [String]
        public let safetyNotes: String?
        public let buildingName: String?
        public let floorLevel: String?
        public let roomNumber: String?
        public let lastCompleted: Date?
        public let frequency: TaskRecurrence
        public let nextDueDate: Date?
        
        public init(id: String, maintenanceTask: MaintenanceTask, contextualInfo: String? = nil, estimatedTime: TimeInterval = 1800, weatherImpact: String? = nil, requiredTools: [String] = [], safetyNotes: String? = nil, buildingName: String? = nil, floorLevel: String? = nil, roomNumber: String? = nil, lastCompleted: Date? = nil, frequency: TaskRecurrence = .none, nextDueDate: Date? = nil) {
            self.id = id
            self.maintenanceTask = maintenanceTask
            self.contextualInfo = contextualInfo
            self.estimatedTime = estimatedTime
            self.weatherImpact = weatherImpact
            self.requiredTools = requiredTools
            self.safetyNotes = safetyNotes
            self.buildingName = buildingName
            self.floorLevel = floorLevel
            self.roomNumber = roomNumber
            self.lastCompleted = lastCompleted
            self.frequency = frequency
            self.nextDueDate = nextDueDate
        }
        
        // Convenience accessors
        public var title: String { maintenanceTask.title }
        public var description: String { maintenanceTask.description }
        public var category: TaskCategory { maintenanceTask.category }
        public var urgency: TaskUrgency { maintenanceTask.urgency }
        public var buildingId: String { maintenanceTask.buildingId }
        public var dueDate: Date? { maintenanceTask.dueDate }
        public var isCompleted: Bool { maintenanceTask.isCompleted }
        public var assignedTo: String? { maintenanceTask.assignedTo }
    }
    
    // MARK: - View Model Support Types
    public struct WeatherImpact: Codable {
        public let condition: WeatherCondition
        public let temperature: Double
        public let affectedTasks: [String] // Task IDs
        public let recommendation: String
        
        public init(condition: WeatherCondition, temperature: Double, affectedTasks: [String], recommendation: String) {
            self.condition = condition
            self.temperature = temperature
            self.affectedTasks = affectedTasks
            self.recommendation = recommendation
        }
    }
    
    public enum DataHealthStatus: Codable, Equatable {
        case unknown
        case healthy
        case warning([String])
        case critical([String])
    }
    
    // MARK: - Worker Routine Models
    public struct WorkerRoutineSummary: Codable {
        public let totalRoutines: Int
        public let completedToday: Int
        public let averageCompletionTime: Double
        public let efficiencyScore: Double
        public let tasksOverdue: Int
        
        public init(totalRoutines: Int, completedToday: Int, averageCompletionTime: Double, efficiencyScore: Double = 0.0, tasksOverdue: Int = 0) {
            self.totalRoutines = totalRoutines
            self.completedToday = completedToday
            self.averageCompletionTime = averageCompletionTime
            self.efficiencyScore = efficiencyScore
            self.tasksOverdue = tasksOverdue
        }
    }
    
    public struct WorkerDailyRoute: Codable {
        public let workerId: String
        public let date: Date
        public let buildings: [NamedCoordinate]
        public let optimizedOrder: [String] // Building IDs in optimal order
        public let totalEstimatedTime: TimeInterval
        public let totalDistance: Double
        
        public init(workerId: String, date: Date, buildings: [NamedCoordinate], optimizedOrder: [String], totalEstimatedTime: TimeInterval, totalDistance: Double) {
            self.workerId = workerId
            self.date = date
            self.buildings = buildings
            self.optimizedOrder = optimizedOrder
            self.totalEstimatedTime = totalEstimatedTime
            self.totalDistance = totalDistance
        }
    }
    
    public struct RouteOptimization: Identifiable, Codable {
        public let id: String
        public let suggestion: String
        public let timeSaving: TimeInterval
        public let distanceSaving: Double
        public let priority: Int
        
        public init(id: String, suggestion: String, timeSaving: TimeInterval, distanceSaving: Double, priority: Int) {
            self.id = id
            self.suggestion = suggestion
            self.timeSaving = timeSaving
            self.distanceSaving = distanceSaving
            self.priority = priority
        }
    }
    
    public struct ScheduleConflict: Identifiable, Codable {
        public let id: String
        public let description: String
        public let severity: TaskUrgency
        public let affectedTasks: [String]
        public let resolution: String?
        
        public init(id: String, description: String, severity: TaskUrgency, affectedTasks: [String], resolution: String? = nil) {
            self.id = id
            self.description = description
            self.severity = severity
            self.affectedTasks = affectedTasks
            self.resolution = resolution
        }
    }
    
    // MARK: - Building Insights
    public struct BuildingInsight: Identifiable, Codable {
        public let id: String
        public let title: String
        public let value: String
        public let trend: String
        public let category: String
        
        public init(id: String, title: String, value: String, trend: String, category: String) {
            self.id = id
            self.title = title
            self.value = value
            self.trend = trend
            self.category = category
        }
    }
    
    public struct BuildingStatistics: Codable {
        public let completionRate: Double
        public let totalTasks: Int
        public let completedTasks: Int
        public let averageCompletionTime: TimeInterval
        public let maintenanceScore: Double
        
        public init(completionRate: Double, totalTasks: Int, completedTasks: Int, averageCompletionTime: TimeInterval = 0, maintenanceScore: Double = 0) {
            self.completionRate = completionRate
            self.totalTasks = totalTasks
            self.completedTasks = completedTasks
            self.averageCompletionTime = averageCompletionTime
            self.maintenanceScore = maintenanceScore
        }
    }
    
    // MARK: - Static Data Collections
    public static let sampleBuildings: [NamedCoordinate] = [
        NamedCoordinate(id: "1", name: "12 West 18th Street", coordinate: CLLocationCoordinate2D(latitude: 40.7389, longitude: -73.9936), address: "12 West 18th Street, New York, NY 10011", imageAssetName: "building_12_w_18th"),
        NamedCoordinate(id: "2", name: "29-31 East 20th Street", coordinate: CLLocationCoordinate2D(latitude: 40.7386, longitude: -73.9883), address: "29-31 East 20th Street, New York, NY 10003", imageAssetName: "building_29_31_e_20th"),
        NamedCoordinate(id: "3", name: "36 Walker Street", coordinate: CLLocationCoordinate2D(latitude: 40.7171, longitude: -74.0026), address: "36 Walker Street, New York, NY 10013", imageAssetName: "building_36_walker"),
        NamedCoordinate(id: "4", name: "41 Elizabeth Street", coordinate: CLLocationCoordinate2D(latitude: 40.7178, longitude: -73.9965), address: "41 Elizabeth Street, New York, NY 10013", imageAssetName: "building_41_elizabeth"),
        NamedCoordinate(id: "5", name: "68 Perry Street", coordinate: CLLocationCoordinate2D(latitude: 40.7351, longitude: -74.0041), address: "68 Perry Street, New York, NY 10014", imageAssetName: "building_68_perry")
    ]
}

// MARK: - Global Type Aliases (Clean, no duplicates, no circular references)
public typealias NamedCoordinate = FrancoSphere.NamedCoordinate
public typealias BuildingTab = FrancoSphere.BuildingTab
public typealias BuildingStatus = FrancoSphere.BuildingStatus
public typealias UserRole = FrancoSphere.UserRole
public typealias WorkerProfile = FrancoSphere.WorkerProfile
public typealias WorkerSkill = FrancoSphere.WorkerSkill
public typealias WorkerSkillCategory = FrancoSphere.WorkerSkillCategory
public typealias WorkerAssignment = FrancoSphere.WorkerAssignment
public typealias InventoryCategory = FrancoSphere.InventoryCategory
public typealias RestockStatus = FrancoSphere.RestockStatus
public typealias InventoryItem = FrancoSphere.InventoryItem
public typealias TaskCategory = FrancoSphere.TaskCategory
public typealias TaskUrgency = FrancoSphere.TaskUrgency
public typealias TaskRecurrence = FrancoSphere.TaskRecurrence
public typealias VerificationStatus = FrancoSphere.VerificationStatus
public typealias MaintenanceTask = FrancoSphere.MaintenanceTask
public typealias TaskCompletionInfo = FrancoSphere.TaskCompletionInfo
public typealias TaskEvidence = FrancoSphere.TaskEvidence
public typealias TaskProgress = FrancoSphere.TaskProgress
public typealias WeatherCondition = FrancoSphere.WeatherCondition
public typealias WeatherData = FrancoSphere.WeatherData
public typealias AIScenario = FrancoSphere.AIScenario
public typealias AISuggestion = FrancoSphere.AISuggestion
public typealias ContextualTask = FrancoSphere.ContextualTask
public typealias WeatherImpact = FrancoSphere.WeatherImpact
public typealias DataHealthStatus = FrancoSphere.DataHealthStatus
public typealias WorkerRoutineSummary = FrancoSphere.WorkerRoutineSummary
public typealias WorkerDailyRoute = FrancoSphere.WorkerDailyRoute
public typealias RouteOptimization = FrancoSphere.RouteOptimization
public typealias ScheduleConflict = FrancoSphere.ScheduleConflict
public typealias BuildingInsight = FrancoSphere.BuildingInsight
public typealias BuildingStatistics = FrancoSphere.BuildingStatistics
