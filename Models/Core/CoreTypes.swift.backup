import Foundation
import CoreLocation
import SwiftUI
import Combine

public struct CoreTypes {
    
    // MARK: - Core ID Types
    public typealias WorkerID = String
    public typealias BuildingID = String
    public typealias TaskID = String
    public typealias AssignmentID = String
    public typealias RoleID = String
    
    // MARK: - Essential Missing Types
    public struct TaskProgress: Codable, Hashable, Identifiable {
        public let id = UUID()
        public let completedTasks: Int
        public let totalTasks: Int
        public let progressPercentage: Double
        
        public init(completedTasks: Int, totalTasks: Int) {
            self.completedTasks = completedTasks
            self.totalTasks = totalTasks
            self.progressPercentage = totalTasks > 0 ? Double(completedTasks) / Double(totalTasks) * 100 : 0
        }
        
        public init(completedTasks: Int, totalTasks: Int, progressPercentage: Double) {
            self.completedTasks = completedTasks
            self.totalTasks = totalTasks
            self.progressPercentage = progressPercentage
        }
    }
    
    public enum BuildingType: String, Codable, CaseIterable {
        case residential = "Residential"
        case commercial = "Commercial"
        case industrial = "Industrial"
        case mixed = "Mixed Use"
        case institutional = "Institutional"
        case other = "Other"
    }
    
    public enum WorkerSkill: String, Codable, CaseIterable {
        case electrical = "Electrical"
        case plumbing = "Plumbing"
        case hvac = "HVAC"
        case carpentry = "Carpentry"
        case cleaning = "Cleaning"
        case security = "Security"
        case maintenance = "General Maintenance"
        case landscaping = "Landscaping"
        case painting = "Painting"
        case other = "Other"
    }
    
    public enum WorkerStatus: String, Codable, CaseIterable {
        case active = "Active"
        case inactive = "Inactive"
        case onBreak = "On Break"
        case unavailable = "Unavailable"
        case clockedIn = "Clocked In"
        case available = "Available"
    }
    
    public enum TaskCategory: String, Codable, CaseIterable {
        case maintenance = "Maintenance"
        case cleaning = "Cleaning"
        case inspection = "Inspection"
        case repair = "Repair"
        case security = "Security"
        case sanitation = "Sanitation"
        case landscaping = "Landscaping"
        case installation = "Installation"
        case utilities = "Utilities"
        case renovation = "Renovation"
        case emergency = "Emergency"
        case other = "Other"
    }
    
    public enum TaskUrgency: String, Codable, CaseIterable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case urgent = "Urgent"
        case emergency = "Emergency"
        case critical = "Critical"
    }
    
    public enum TaskRecurrence: String, Codable, CaseIterable {
        case none = "None"
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
        case quarterly = "Quarterly"
        case annually = "Annually"
    }
    
    public enum WeatherCondition: String, Codable, CaseIterable {
        case clear = "Clear"
        case cloudy = "Cloudy"
        case rain = "Rain"
        case snow = "Snow"
        case storm = "Storm"
        case fog = "Fog"
        case windy = "Windy"
        case unknown = "Unknown"
    }
    
    public enum OutdoorWorkRisk: String, Codable, CaseIterable {
        case low = "Low"
        case moderate = "Moderate"
        case high = "High"
        case extreme = "Extreme"
    }
    
    public enum AIPriority: String, Codable, CaseIterable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case urgent = "Urgent"
        case critical = "Critical"
    }
    
    public struct AISuggestion: Codable, Hashable, Identifiable {
        public let id: String
        public let title: String
        public let description: String
        public let priority: AIPriority
        public let buildingId: String?
        public let category: String
        public let createdAt: Date
        
        public init(id: String = UUID().uuidString, title: String, description: String, priority: AIPriority, buildingId: String? = nil, category: String, createdAt: Date = Date()) {
            self.id = id
            self.title = title
            self.description = description
            self.priority = priority
            self.buildingId = buildingId
            self.category = category
            self.createdAt = createdAt
        }
    }
    
    public struct AIRecommendedAction: Codable, Hashable, Identifiable {
        public let id: String
        public let title: String
        public let description: String
        public let priority: AIPriority
        public let estimatedCost: Double?
        public let estimatedTime: TimeInterval?
        public let buildingId: String
        
        public init(id: String = UUID().uuidString, title: String, description: String, priority: AIPriority, estimatedCost: Double? = nil, estimatedTime: TimeInterval? = nil, buildingId: String) {
            self.id = id
            self.title = title
            self.description = description
            self.priority = priority
            self.estimatedCost = estimatedCost
            self.estimatedTime = estimatedTime
            self.buildingId = buildingId
        }
    }
    
    public struct AIRiskAssessment: Codable, Hashable, Identifiable {
        public let id: String
        public let title: String
        public let description: String
        public let riskLevel: AIPriority
        public let mitigation: String
        public let buildingId: String
        
        public init(id: String = UUID().uuidString, title: String, description: String, riskLevel: AIPriority, mitigation: String, buildingId: String) {
            self.id = id
            self.title = title
            self.description = description
            self.riskLevel = riskLevel
            self.mitigation = mitigation
            self.buildingId = buildingId
        }
    }
    
    // MARK: - AI Scenario Types
    public enum AIScenarioType: String, Codable, CaseIterable {
        case weatherAlert = "Weather Alert"
        case maintenanceRequired = "Maintenance Required"
        case emergencyResponse = "Emergency Response"
        case taskCompletion = "Task Completion"
        case buildingArrival = "Building Arrival"
        case routineIncomplete = "Routine Incomplete"
        case scheduleConflict = "Schedule Conflict"
        case clockOutReminder = "Clock Out Reminder"
        case pendingTasks = "Pending Tasks"
        case missingPhoto = "Missing Photo"
        case inventoryLow = "Inventory Low"
    }
    
    public struct AIScenario: Codable, Hashable, Identifiable {
        public let id = UUID()
        public let title: String
        public let description: String
        public let type: AIScenarioType
        public let priority: AIPriority
        public let suggestions: [AISuggestion]
        public let createdAt: Date
        
        public init(title: String, description: String, type: AIScenarioType, priority: AIPriority, suggestions: [AISuggestion] = [], createdAt: Date = Date()) {
            self.title = title
            self.description = description
            self.type = type
            self.priority = priority
            self.suggestions = suggestions
            self.createdAt = createdAt
        }
    }
    
    public struct AIScenarioData: Codable, Hashable {
        public let scenario: AIScenario
        public let message: String
        public let actionText: String
        public let hasPendingScenarios: Bool
        public let lastUpdated: Date
        
        public init(scenario: AIScenario, message: String, actionText: String, hasPendingScenarios: Bool = true, lastUpdated: Date = Date()) {
            self.scenario = scenario
            self.message = message
            self.actionText = actionText
            self.hasPendingScenarios = hasPendingScenarios
            self.lastUpdated = lastUpdated
        }
    }
    
    // MARK: - Compliance Types
    public enum ComplianceIssueType: String, Codable, CaseIterable {
        case safety = "Safety"
        case health = "Health"
        case fire = "Fire Safety"
        case accessibility = "Accessibility"
        case environmental = "Environmental"
        case structural = "Structural"
        case electrical = "Electrical"
        case plumbing = "Plumbing"
        case other = "Other"
    }
    
    public enum ComplianceSeverity: String, Codable, CaseIterable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case critical = "Critical"
    }
    
    public enum ComplianceStatus: String, Codable, CaseIterable {
        case compliant = "Compliant"
        case nonCompliant = "Non-Compliant"
        case pending = "Pending"
        case underReview = "Under Review"
        case resolved = "Resolved"
    }
    
    public struct ComplianceIssue: Codable, Hashable, Identifiable {
        public let id: String
        public let type: ComplianceIssueType
        public let severity: ComplianceSeverity
        public let description: String
        public let buildingId: String
        public let dueDate: Date?
        public let resolvedDate: Date?
        
        public var isResolved: Bool { resolvedDate != nil }
        
        public init(id: String = UUID().uuidString, type: ComplianceIssueType, severity: ComplianceSeverity, description: String, buildingId: String, dueDate: Date? = nil, resolvedDate: Date? = nil) {
            self.id = id
            self.type = type
            self.severity = severity
            self.description = description
            self.buildingId = buildingId
            self.dueDate = dueDate
            self.resolvedDate = resolvedDate
        }
    }
    
    public enum ComplianceTab: String, CaseIterable {
        case overview = "Overview"
        case issues = "Issues"
        case reports = "Reports"
        case history = "History"
    }
    
    // MARK: - Worker Assignment Types
    public enum AssignmentType: String, Codable, CaseIterable {
        case permanent = "Permanent"
        case temporary = "Temporary"
        case contract = "Contract"
        case emergency = "Emergency"
        case coverage = "Coverage"
    }
    
    public struct WorkerAssignment: Codable, Hashable, Identifiable {
        public let id: String
        public let workerId: String
        public let buildingId: String
        public let assignmentType: AssignmentType
        public let startDate: Date
        public let endDate: Date?
        public let isActive: Bool
        
        public init(id: String = UUID().uuidString, workerId: String, buildingId: String, assignmentType: AssignmentType, startDate: Date, endDate: Date? = nil, isActive: Bool = true) {
            self.id = id
            self.workerId = workerId
            self.buildingId = buildingId
            self.assignmentType = assignmentType
            self.startDate = startDate
            self.endDate = endDate
            self.isActive = isActive
        }
    }
    
    // MARK: - Franco-specific Types
    public typealias FrancoWorkerAssignment = WorkerAssignment
    
    // MARK: - Building Types
    public enum BuildingTab: String, CaseIterable {
        case overview = "Overview"
        case tasks = "Tasks"
        case metrics = "Metrics"
        case intelligence = "Intelligence"
        case compliance = "Compliance"
    }
    
    public struct BuildingMetrics: Codable, Hashable, Identifiable {
        public let id: String
        public let buildingId: String
        public let occupancyRate: Double
        public let maintenanceScore: Double
        public let complianceScore: Double
        public let energyEfficiency: Double
        public let safetyScore: Double
        public let lastUpdated: Date
        
        public init(id: String = UUID().uuidString, buildingId: String, occupancyRate: Double, maintenanceScore: Double, complianceScore: Double, energyEfficiency: Double, safetyScore: Double, lastUpdated: Date = Date()) {
            self.id = id
            self.buildingId = buildingId
            self.occupancyRate = occupancyRate
            self.maintenanceScore = maintenanceScore
            self.complianceScore = complianceScore
            self.energyEfficiency = energyEfficiency
            self.safetyScore = safetyScore
            self.lastUpdated = lastUpdated
        }
    }
    
    public struct BuildingStatistics: Codable, Hashable {
        public let totalBuildings: Int
        public let activeBuildings: Int
        public let averageOccupancy: Double
        public let totalMaintenanceRequests: Int
        public let completedMaintenanceRequests: Int
        public let pendingMaintenanceRequests: Int
        
        public init(totalBuildings: Int, activeBuildings: Int, averageOccupancy: Double, totalMaintenanceRequests: Int, completedMaintenanceRequests: Int, pendingMaintenanceRequests: Int) {
            self.totalBuildings = totalBuildings
            self.activeBuildings = activeBuildings
            self.averageOccupancy = averageOccupancy
            self.totalMaintenanceRequests = totalMaintenanceRequests
            self.completedMaintenanceRequests = completedMaintenanceRequests
            self.pendingMaintenanceRequests = pendingMaintenanceRequests
        }
    }
    
    // MARK: - Status Types
    public enum VerificationStatus: String, Codable, CaseIterable {
        case pending = "Pending"
        case verified = "Verified"
        case rejected = "Rejected"
        case expired = "Expired"
    }
    
    public enum TrendDirection: String, Codable, CaseIterable {
        case up = "Up"
        case down = "Down"
        case stable = "Stable"
        case improving = "Improving"
        case declining = "Declining"
        case unknown = "Unknown"
    }
    
    // MARK: - Analytics Types
    public struct BuildingAnalytics: Codable {
        public let buildingId: String
        public let occupancyRate: Double
        public let maintenanceScore: Double
        public let complianceScore: Double
        public let energyEfficiency: Double
        public let lastUpdated: Date
        
        public init(buildingId: String, occupancyRate: Double, maintenanceScore: Double, complianceScore: Double, energyEfficiency: Double, lastUpdated: Date = Date()) {
            self.buildingId = buildingId
            self.occupancyRate = occupancyRate
            self.maintenanceScore = maintenanceScore
            self.complianceScore = complianceScore
            self.energyEfficiency = energyEfficiency
            self.lastUpdated = lastUpdated
        }
    }
    
    public struct PortfolioIntelligence: Codable {
        public let totalValue: Double
        public let occupancyRate: Double
        public let maintenanceScore: Double
        public let complianceIssues: [ComplianceIssue]
        public let trends: [String: TrendDirection]
        public let lastUpdated: Date
        
        public init(totalValue: Double, occupancyRate: Double, maintenanceScore: Double, complianceIssues: [ComplianceIssue], trends: [String: TrendDirection], lastUpdated: Date = Date()) {
            self.totalValue = totalValue
            self.occupancyRate = occupancyRate
            self.maintenanceScore = maintenanceScore
            self.complianceIssues = complianceIssues
            self.trends = trends
            self.lastUpdated = lastUpdated
        }
    }
    
    // MARK: - Intelligence Types
    public struct IntelligenceInsight: Codable, Hashable, Identifiable {
        public let id: String
        public let title: String
        public let description: String
        public let type: InsightType
        public let priority: InsightPriority
        public let actionable: Bool
        public let timestamp: Date
        
        public init(id: String = UUID().uuidString, title: String, description: String, type: InsightType, priority: InsightPriority, actionable: Bool, timestamp: Date = Date()) {
            self.id = id
            self.title = title
            self.description = description
            self.type = type
            self.priority = priority
            self.actionable = actionable
            self.timestamp = timestamp
        }
    }
    
    public enum InsightType: String, Codable, CaseIterable {
        case performance = "Performance"
        case maintenance = "Maintenance"
        case compliance = "Compliance"
        case efficiency = "Efficiency"
        case cost = "Cost"
        case safety = "Safety"
    }
    
    public enum InsightPriority: String, Codable, CaseIterable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case urgent = "Urgent"
        case critical = "Critical"
    }
    
    // MARK: - Inventory Types
    public enum InventoryCategory: String, Codable, CaseIterable {
        case tools = "Tools"
        case supplies = "Supplies"
        case equipment = "Equipment"
        case materials = "Materials"
        case safety = "Safety"
        case other = "Other"
    }
    
    public enum RestockStatus: String, Codable, CaseIterable {
        case inStock = "In Stock"
        case lowStock = "Low Stock"
        case outOfStock = "Out of Stock"
        case onOrder = "On Order"
    }
    
    public struct InventoryItem: Codable, Identifiable {
        public let id: String
        public let name: String
        public let category: InventoryCategory
        public let currentStock: Int
        public let minimumStock: Int
        public let unit: String
        public let restockStatus: RestockStatus
        
        public init(id: String = UUID().uuidString, name: String, category: InventoryCategory, currentStock: Int, minimumStock: Int, unit: String = "unit", restockStatus: RestockStatus = .inStock) {
            self.id = id
            self.name = name
            self.category = category
            self.currentStock = currentStock
            self.minimumStock = minimumStock
            self.unit = unit
            self.restockStatus = restockStatus
        }
    }
    
    // MARK: - Worker Routing Types
    public struct WorkerDailyRoute: Codable, Identifiable {
        public let id: String
        public let workerId: String
        public let date: Date
        public let buildings: [String]
        public let optimizedOrder: [String]
        public let estimatedTravelTime: TimeInterval
        public let actualTravelTime: TimeInterval?
        
        public init(id: String = UUID().uuidString, workerId: String, date: Date, buildings: [String], optimizedOrder: [String], estimatedTravelTime: TimeInterval, actualTravelTime: TimeInterval? = nil) {
            self.id = id
            self.workerId = workerId
            self.date = date
            self.buildings = buildings
            self.optimizedOrder = optimizedOrder
            self.estimatedTravelTime = estimatedTravelTime
            self.actualTravelTime = actualTravelTime
        }
    }
    
    public struct RouteOptimization: Codable {
        public let originalRoute: [String]
        public let optimizedRoute: [String]
        public let timeSaved: TimeInterval
        public let distanceSaved: Double
        public let fuelSaved: Double
        
        public init(originalRoute: [String], optimizedRoute: [String], timeSaved: TimeInterval, distanceSaved: Double, fuelSaved: Double) {
            self.originalRoute = originalRoute
            self.optimizedRoute = optimizedRoute
            self.timeSaved = timeSaved
            self.distanceSaved = distanceSaved
            self.fuelSaved = fuelSaved
        }
    }
    
    // MARK: - Maintenance Types
    public struct MaintenanceRecord: Codable, Identifiable {
        public let id: String
        public let buildingId: String
        public let taskId: String
        public let workerId: String
        public let description: String
        public let completedDate: Date
        public let cost: Double?
        public let notes: String?
        
        public init(id: String = UUID().uuidString, buildingId: String, taskId: String, workerId: String, description: String, completedDate: Date, cost: Double? = nil, notes: String? = nil) {
            self.id = id
            self.buildingId = buildingId
            self.taskId = taskId
            self.workerId = workerId
            self.description = description
            self.completedDate = completedDate
            self.cost = cost
            self.notes = notes
        }
    }
    
    // MARK: - Additional Types for ViewModels
    public struct TaskTrends: Codable {
        public let direction: TrendDirection
        public let changePercent: Double
        public let period: String
        
        public init(direction: TrendDirection, changePercent: Double, period: String) {
            self.direction = direction
            self.changePercent = changePercent
            self.period = period
        }
    }
    
    public struct PerformanceMetrics: Codable {
        public let completionRate: Double
        public let averageTime: TimeInterval
        public let qualityScore: Double
        
        public init(completionRate: Double, averageTime: TimeInterval, qualityScore: Double) {
            self.completionRate = completionRate
            self.averageTime = averageTime
            self.qualityScore = qualityScore
        }
    }
    
    public struct StreakData: Codable {
        public let currentStreak: Int
        public let longestStreak: Int
        public let lastCompletionDate: Date?
        
        public init(currentStreak: Int, longestStreak: Int, lastCompletionDate: Date? = nil) {
            self.currentStreak = currentStreak
            self.longestStreak = longestStreak
            self.lastCompletionDate = lastCompletionDate
        }
    }
    
    public struct TaskCompletionRecord: Codable {
        public let taskId: String
        public let completedDate: Date
        public let workerId: String
        
        public init(taskId: String, completedDate: Date, workerId: String) {
            self.taskId = taskId
            self.completedDate = completedDate
            self.workerId = workerId
        }
    }
    
    public struct MaintenanceTask: Codable, Hashable, Identifiable {
        public let id: String
        public let title: String
        public let description: String
        public let category: TaskCategory
        public let urgency: TaskUrgency
        public let buildingId: String
        public let assignedWorkerId: String?
        public let createdDate: Date
        public let dueDate: Date
        public let isCompleted: Bool
        public let recurrence: TaskRecurrence
        
        public init(id: String = UUID().uuidString, title: String, description: String, category: TaskCategory, urgency: TaskUrgency, buildingId: String, assignedWorkerId: String? = nil, createdDate: Date = Date(), dueDate: Date, isCompleted: Bool = false, recurrence: TaskRecurrence = .none) {
            self.id = id
            self.title = title
            self.description = description
            self.category = category
            self.urgency = urgency
            self.buildingId = buildingId
            self.assignedWorkerId = assignedWorkerId
            self.createdDate = createdDate
            self.dueDate = dueDate
            self.isCompleted = isCompleted
            self.recurrence = recurrence
        }
    }
    
    public struct User: Codable, Hashable, Identifiable {
        public let id: String
        public let workerId: WorkerID
        public let name: String
        public let email: String
        public let role: String
        
        public init(id: String = UUID().uuidString, workerId: WorkerID, name: String, email: String, role: String) {
            self.id = id
            self.workerId = workerId
            self.name = name
            self.email = email
            self.role = role
        }
    }
}

// MARK: - Global Type Aliases
public typealias WorkerID = CoreTypes.WorkerID
public typealias BuildingID = CoreTypes.BuildingID
public typealias TaskID = CoreTypes.TaskID
public typealias AssignmentID = CoreTypes.AssignmentID
public typealias RoleID = CoreTypes.RoleID
public typealias TaskProgress = CoreTypes.TaskProgress
public typealias BuildingType = CoreTypes.BuildingType
public typealias WorkerSkill = CoreTypes.WorkerSkill
public typealias WorkerStatus = CoreTypes.WorkerStatus
public typealias TaskCategory = CoreTypes.TaskCategory
public typealias TaskUrgency = CoreTypes.TaskUrgency
public typealias TaskRecurrence = CoreTypes.TaskRecurrence
public typealias MaintenanceTask = CoreTypes.MaintenanceTask
public typealias WeatherCondition = CoreTypes.WeatherCondition
public typealias OutdoorWorkRisk = CoreTypes.OutdoorWorkRisk
public typealias AISuggestion = CoreTypes.AISuggestion
public typealias AIPriority = CoreTypes.AIPriority
public typealias AIRecommendedAction = CoreTypes.AIRecommendedAction
public typealias AIRiskAssessment = CoreTypes.AIRiskAssessment
public typealias AIScenario = CoreTypes.AIScenario
public typealias AIScenarioData = CoreTypes.AIScenarioData
public typealias AIScenarioType = CoreTypes.AIScenarioType
public typealias ComplianceIssueType = CoreTypes.ComplianceIssueType
public typealias ComplianceSeverity = CoreTypes.ComplianceSeverity
public typealias ComplianceIssue = CoreTypes.ComplianceIssue
public typealias ComplianceTab = CoreTypes.ComplianceTab
public typealias ComplianceStatus = CoreTypes.ComplianceStatus
public typealias AssignmentType = CoreTypes.AssignmentType
public typealias WorkerAssignment = CoreTypes.WorkerAssignment
public typealias FrancoWorkerAssignment = CoreTypes.FrancoWorkerAssignment
public typealias BuildingTab = CoreTypes.BuildingTab
public typealias BuildingMetrics = CoreTypes.BuildingMetrics
public typealias BuildingStatistics = CoreTypes.BuildingStatistics
public typealias VerificationStatus = CoreTypes.VerificationStatus
public typealias TrendDirection = CoreTypes.TrendDirection
public typealias BuildingAnalytics = CoreTypes.BuildingAnalytics
public typealias PortfolioIntelligence = CoreTypes.PortfolioIntelligence
public typealias IntelligenceInsight = CoreTypes.IntelligenceInsight
public typealias InsightType = CoreTypes.InsightType
public typealias InsightPriority = CoreTypes.InsightPriority
public typealias InventoryCategory = CoreTypes.InventoryCategory
public typealias RestockStatus = CoreTypes.RestockStatus
public typealias InventoryItem = CoreTypes.InventoryItem
public typealias WorkerDailyRoute = CoreTypes.WorkerDailyRoute
public typealias RouteOptimization = CoreTypes.RouteOptimization
public typealias MaintenanceRecord = CoreTypes.MaintenanceRecord
public typealias TaskTrends = CoreTypes.TaskTrends
public typealias PerformanceMetrics = CoreTypes.PerformanceMetrics
public typealias StreakData = CoreTypes.StreakData
public typealias TaskCompletionRecord = CoreTypes.TaskCompletionRecord
