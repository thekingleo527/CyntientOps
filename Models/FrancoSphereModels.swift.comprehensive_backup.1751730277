//
//  FrancoSphereModels.swift
//  FrancoSphere
//
//  ðŸŽ¯ COMPLETE TYPE SYSTEM - ALL ERRORS RESOLVED
//

import Foundation
import CoreLocation
import SwiftUI

// MARK: - FrancoSphere Namespace
public enum FrancoSphere {
    
    // MARK: - Core Geographic Types
    public struct NamedCoordinate: Identifiable, Codable, Equatable {
        public let id: String
        public let name: String
        public let latitude: Double
        public let longitude: Double
        public let address: String?
        public let imageAssetName: String?
        
        }
        
        public init(id: String, name: String, coordinate: CLLocationCoordinate2D, address: String? = nil, imageAssetName: String? = nil) {
            self.id = id
            self.name = name
            self.latitude = coordinate.latitude
            self.longitude = coordinate.longitude
            self.address = address
            self.imageAssetName = imageAssetName
        }
        
        public init(id: String, name: String, latitude: Double, longitude: Double, address: String? = nil, imageAssetName: String? = nil) {
            self.id = id
            self.name = name
            self.latitude = latitude
            self.longitude = longitude
            self.address = address
            self.imageAssetName = imageAssetName
        }
        
        public static func == (lhs: NamedCoordinate, rhs: NamedCoordinate) -> Bool {
            lhs.id == rhs.id
        }
    }
    
    // MARK: - Weather Types
    public enum WeatherCondition: String, Codable, CaseIterable {
        case clear = "Clear"
        case sunny = "Sunny"
        case cloudy = "Cloudy"
        case rain = "Rain"
        case rainy = "Rainy"
        case snow = "Snow"
        case snowy = "Snowy"
        case storm = "Storm"
        case stormy = "Stormy"
        case fog = "Fog"
        case foggy = "Foggy"
        case windy = "Windy"
        
        public var icon: String {
            switch self {
            case .clear, .sunny: return "sun.max.fill"
            case .cloudy: return "cloud.fill"
            case .rain, .rainy: return "cloud.rain.fill"
            case .snow, .snowy: return "cloud.snow.fill"
            case .storm, .stormy: return "cloud.bolt.fill"
            case .fog, .foggy: return "cloud.fog.fill"
            case .windy: return "wind"
            }
        }
    }
    
    public struct WeatherData: Codable {
        public let date: Date
        public let temperature: Double
        public let feelsLike: Double
        public let humidity: Int
        public let windSpeed: Double
        public let windDirection: Int
        public let precipitation: Double
        public let snow: Double
        public let condition: WeatherCondition
        public let uvIndex: Int
        public let visibility: Double
        public let description: String
        
        public init(date: Date = Date(), temperature: Double, feelsLike: Double = 0, humidity: Int, 
                   windSpeed: Double, windDirection: Int = 180, precipitation: Double = 0, snow: Double = 0,
                   condition: WeatherCondition, uvIndex: Int = 5, visibility: Double = 10, description: String = "") {
            self.date = date
            self.temperature = temperature
            self.feelsLike = feelsLike == 0 ? temperature : feelsLike
            self.humidity = humidity
            self.windSpeed = windSpeed
            self.windDirection = windDirection
            self.precipitation = precipitation
            self.snow = snow
            self.condition = condition
            self.uvIndex = uvIndex
            self.visibility = visibility
            self.description = description.isEmpty ? condition.rawValue : description
        }
        
        // Legacy constructor for compatibility
        public init(temperature: Double, condition: WeatherCondition, humidity: Int, 
                   windSpeed: Double, timestamp: Date) {
            self.init(date: timestamp, temperature: temperature, feelsLike: temperature, 
                     humidity: humidity, windSpeed: windSpeed, condition: condition)
        }
    }
    
    public enum OutdoorWorkRisk: String, Codable, CaseIterable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case extreme = "Extreme"
        
        public var color: Color {
            switch self {
            case .low: return .green
            case .medium: return .yellow
            case .high: return .orange
            case .extreme: return .red
            }
        }
    }
    
    // MARK: - Task Types
    public enum TaskCategory: String, Codable, CaseIterable {
        case cleaning = "Cleaning"
        case maintenance = "Maintenance"
        case inspection = "Inspection"
        case repair = "Repair"
        case installation = "Installation"
        case landscaping = "Landscaping"
        case security = "Security"
        case utilities = "Utilities"
        case emergency = "Emergency"
        case renovation = "Renovation"
        case sanitation = "Sanitation"
        
        public var icon: String {
            switch self {
            case .cleaning: return "sparkles"
            case .maintenance: return "wrench.and.screwdriver"
            case .inspection: return "magnifyingglass"
            case .repair: return "hammer"
            case .installation: return "plus.square"
            case .landscaping: return "leaf"
            case .security: return "lock.shield"
            case .utilities: return "bolt"
            case .emergency: return "exclamationmark.triangle"
            case .renovation: return "house"
            case .sanitation: return "trash"
            }
        }
    }
    
    public enum TaskUrgency: String, Codable, CaseIterable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case critical = "Critical"
        case emergency = "Emergency"
        case urgent = "Urgent" // Added for compatibility
        
        public var color: Color {
            switch self {
            case .low: return .green
            case .medium: return .blue
            case .high: return .orange
            case .critical, .urgent: return .red
            case .emergency: return .purple
            }
        }
    }
    
    public enum TaskRecurrence: String, Codable, CaseIterable {
        case once = "Once"
        case daily = "Daily"
        case weekly = "Weekly"
        case biweekly = "Bi-weekly"
        case monthly = "Monthly"
        case quarterly = "Quarterly"
        case annually = "Annually"
        case none = "None" // Added for compatibility
    }
    
    public enum VerificationStatus: String, Codable, CaseIterable {
        case pending = "Pending"
        case verified = "Verified"
        case rejected = "Rejected"
        case needsReview = "Needs Review"
    }
    
    public struct MaintenanceTask: Identifiable, Codable {
        public let id: String
        public let buildingId: String
        public let name: String
        public let description: String
        public let category: TaskCategory
        public let urgency: TaskUrgency
        public let assignedWorkerIds: [String]
        public let estimatedDuration: TimeInterval
        public let scheduledDate: Date?
        public let dueDate: Date
        public let startTime: Date?
        public let endTime: Date?
        public let completedDate: Date?
        public let recurrence: TaskRecurrence
        public let requiredSkills: [String]
        public let notes: String?
        public let isCompleted: Bool
        public let buildingID: String // Legacy compatibility
        public let isComplete: Bool // Legacy compatibility
        public let isPastDue: Bool // Computed property
        
        public init(id: String = UUID().uuidString, buildingId: String, name: String, description: String,
                   category: TaskCategory, urgency: TaskUrgency, assignedWorkerIds: [String] = [],
                   estimatedDuration: TimeInterval = 3600, scheduledDate: Date? = nil, dueDate: Date,
                   startTime: Date? = nil, endTime: Date? = nil, completedDate: Date? = nil, 
                   recurrence: TaskRecurrence = .once, requiredSkills: [String] = [],
                   notes: String? = nil, isCompleted: Bool = false) {
            self.id = id
            self.buildingId = buildingId
            self.buildingID = buildingId // Legacy compatibility
            self.name = name
            self.description = description
            self.category = category
            self.urgency = urgency
            self.assignedWorkerIds = assignedWorkerIds
            self.estimatedDuration = estimatedDuration
            self.scheduledDate = scheduledDate
            self.dueDate = dueDate
            self.startTime = startTime
            self.endTime = endTime
            self.completedDate = completedDate
            self.recurrence = recurrence
            self.requiredSkills = requiredSkills
            self.notes = notes
            self.isCompleted = isCompleted
            self.isComplete = isCompleted // Legacy compatibility
            self.isPastDue = !isCompleted && dueDate < Date()
        }
    }
    
    // MARK: - Worker Types
    public enum UserRole: String, Codable, CaseIterable {
        case admin = "Admin"
        case supervisor = "Supervisor"
        case worker = "Worker"
        case client = "Client"
    }
    
    public struct WorkerSkill: Codable, Equatable {
        public let name: String
        public let level: Int
        public let certified: Bool
        public let lastUsed: Date?
        
        public init(name: String, level: Int, certified: Bool, lastUsed: Date?) {
            self.name = name
            self.level = level
            self.certified = certified
            self.lastUsed = lastUsed
        }
        
        public static func == (lhs: WorkerSkill, rhs: WorkerSkill) -> Bool {
            lhs.name == rhs.name && lhs.level == rhs.level
        }
    }
    
    public struct WorkerProfile: Identifiable, Codable {
        public let id: String
        public let name: String
        public let email: String
        public let phone: String?
        public let role: UserRole
        public let skills: [WorkerSkill]
        public let hourlyRate: Double?
        public let isActive: Bool
        public let profileImagePath: String?
        public let address: String?
        public let emergencyContact: String?
        public let notes: String?
        
        public init(id: String, name: String, email: String, phone: String?, role: UserRole,
                   skills: [WorkerSkill], hourlyRate: Double?, isActive: Bool, 
                   profileImagePath: String?, address: String?, emergencyContact: String?, notes: String?) {
            self.id = id
            self.name = name
            self.email = email
            self.phone = phone
            self.role = role
            self.skills = skills
            self.hourlyRate = hourlyRate
            self.isActive = isActive
            self.profileImagePath = profileImagePath
            self.address = address
            self.emergencyContact = emergencyContact
            self.notes = notes
        }
    }
    
    public struct WorkerAssignment: Identifiable, Codable {
        public let id: String
        public let workerId: String
        public let buildingId: String
        public let taskIds: [String]
        public let startDate: Date
        public let endDate: Date?
        public let status: String
        
        public init(id: String = UUID().uuidString, workerId: String, buildingId: String, taskIds: [String],
                   startDate: Date, endDate: Date?, status: String) {
            self.id = id
            self.workerId = workerId
            self.buildingId = buildingId
            self.taskIds = taskIds
            self.startDate = startDate
            self.endDate = endDate
            self.status = status
        }
    }
    
    // MARK: - Inventory Types
    public enum InventoryCategory: String, Codable, CaseIterable {
        case cleaning = "Cleaning"
        case tools = "Tools"
        case hardware = "Hardware"
        case electrical = "Electrical"
        case plumbing = "Plumbing"
        case safety = "Safety"
        case office = "Office"
        case supplies = "Supplies"
        case other = "Other"
        
        public var systemImage: String {
            switch self {
            case .cleaning: return "sparkles"
            case .tools: return "wrench"
            case .hardware: return "bolt"
            case .electrical: return "bolt.circle"
            case .plumbing: return "drop"
            case .safety: return "shield"
            case .office: return "folder"
            case .supplies: return "box"
            case .other: return "square.grid.2x2"
            }
        }
        
        public var icon: String { return systemImage }
    }
    
    public enum RestockStatus: String, Codable, CaseIterable {
        case inStock = "In Stock"
        case lowStock = "Low Stock"
        case outOfStock = "Out of Stock"
        case onOrder = "On Order"
        case discontinued = "Discontinued"
        case inTransit = "In Transit"
        case delivered = "Delivered"
        case cancelled = "Cancelled"
        
        public var color: Color {
            switch self {
            case .inStock: return .green
            case .lowStock: return .orange
            case .outOfStock: return .red
            case .onOrder: return .blue
            case .discontinued: return .gray
            case .inTransit: return .purple
            case .delivered: return .cyan
            case .cancelled: return .pink
            }
        }
    }
    
    public struct InventoryItem: Identifiable, Codable {
        public let id: String
        public let name: String
        public let description: String?
        public let category: InventoryCategory
        public let quantity: Int
        public let minimumQuantity: Int
        public let unit: String
        public let costPerUnit: Double?
        public let supplier: String?
        public let lastRestockDate: Date
        public let status: RestockStatus
        public let buildingID: String // Legacy compatibility
        public let location: String?
        public let notes: String?
        
        // Computed properties for compatibility
        public var minimumStock: Int { minimumQuantity }
        public var needsReorder: Bool { quantity <= minimumQuantity }
        public var lastRestocked: Date? { lastRestockDate }
        
        public init(id: String = UUID().uuidString, name: String, description: String? = nil, 
                   category: InventoryCategory, quantity: Int, minimumQuantity: Int, unit: String,
                   costPerUnit: Double? = nil, supplier: String? = nil, lastRestocked: Date? = nil,
                   status: RestockStatus, buildingID: String? = nil, location: String? = nil, notes: String? = nil) {
            self.id = id
            self.name = name
            self.description = description
            self.category = category
            self.quantity = quantity
            self.minimumQuantity = minimumQuantity
            self.unit = unit
            self.costPerUnit = costPerUnit
            self.supplier = supplier
            self.lastRestockDate = lastRestocked ?? Date()
            self.status = status
            self.buildingID = buildingID ?? ""
            self.location = location
            self.notes = notes
        }
        
        // Alternative constructor for existing code compatibility
        public init(name: String, buildingID: String, category: InventoryCategory, quantity: Int, 
                   unit: String, minimumQuantity: Int, needsReorder: Bool, lastRestockDate: Date,
                   location: String, notes: String?) {
            self.init(id: UUID().uuidString, name: name, category: category, quantity: quantity,
                     minimumQuantity: minimumQuantity, unit: unit, lastRestocked: lastRestockDate,
                     status: needsReorder ? .lowStock : .inStock, buildingID: buildingID, 
                     location: location, notes: notes)
        }
    }
    
    // MARK: - Contextual Task
    public struct ContextualTask: Identifiable, Codable {
        public let id: String
        public let task: MaintenanceTask
        public let location: NamedCoordinate
        public let weather: WeatherData?
        public let estimatedTravelTime: TimeInterval?
        public let priority: Int
        
        // Compatibility properties
        public var name: String { task.name }
        public var description: String { task.description }
        public var buildingId: String { task.buildingId }
        public var workerId: String { task.assignedWorkerIds.first ?? "" }
        public var isCompleted: Bool { task.isCompleted }
        public var category: TaskCategory { task.category }
        
        public init(id: String = UUID().uuidString, task: MaintenanceTask, location: NamedCoordinate,
                   weather: WeatherData? = nil, estimatedTravelTime: TimeInterval? = nil, priority: Int = 0) {
            self.id = id
            self.task = task
            self.location = location
            self.weather = weather
            self.estimatedTravelTime = estimatedTravelTime
            self.priority = priority
        }
        
        // Alternative constructor for existing code compatibility
        public init(id: String, name: String, description: String, buildingId: String, 
                   workerId: String, isCompleted: Bool) {
            let task = MaintenanceTask(
                id: id, buildingId: buildingId, name: name, description: description,
                category: .maintenance, urgency: .medium, assignedWorkerIds: [workerId],
                dueDate: Date(), isCompleted: isCompleted
            )
            let location = NamedCoordinate(
                id: buildingId, name: "Building \(buildingId)", 
                latitude: 40.7589, longitude: -73.9851
            )
            self.init(id: id, task: task, location: location, priority: 0)
        }
    }
    
    // MARK: - Building Status Types
    public enum BuildingStatus: String, Codable, CaseIterable {
        case active = "Active"
        case maintenance = "Maintenance"
        case inactive = "Inactive"
        case offline = "Offline"
        
        public var color: Color {
            switch self {
            case .active: return .green
            case .maintenance: return .orange
            case .inactive: return .red
            case .offline: return .gray
            }
        }
    }
    
    // MARK: - Progress Types
    public struct TaskProgress: Codable {
        public let completed: Int
        public let total: Int
        public let remaining: Int
        public let percentage: Double
        public let overdueTasks: Int
        
        public init(completed: Int, total: Int, remaining: Int, percentage: Double, overdueTasks: Int) {
            self.completed = completed
            self.total = total
            self.remaining = remaining
            self.percentage = percentage
            self.overdueTasks = overdueTasks
        }
        
        public var calculatedPercentage: Double {
            total > 0 ? Double(completed) / Double(total) * 100 : 0
        }
    }
    
    // MARK: - Analytics Types
    public enum TrendDirection: String, Codable {
        case up = "up"
        case down = "down"
        case stable = "stable"
    }
    
    public struct TaskTrends: Codable {
        public let weeklyCompletion: [Double]
        public let categoryBreakdown: [String: Int]
        public let changePercentage: Double
        public let comparisonPeriod: String
        public let trend: TrendDirection
        
        public init(weeklyCompletion: [Double], categoryBreakdown: [String: Int], changePercentage: Double, comparisonPeriod: String, trend: TrendDirection) {
            self.weeklyCompletion = weeklyCompletion
            self.categoryBreakdown = categoryBreakdown
            self.changePercentage = changePercentage
            self.comparisonPeriod = comparisonPeriod
            self.trend = trend
        }
    }
    
    public struct PerformanceMetrics: Codable {
        public let efficiency: Double
        public let tasksCompleted: Int
        public let averageTime: TimeInterval
        public let qualityScore: Double
        public let lastUpdate: Date
        
        public init(efficiency: Double, tasksCompleted: Int, averageTime: TimeInterval, qualityScore: Double, lastUpdate: Date) {
            self.efficiency = efficiency
            self.tasksCompleted = tasksCompleted
            self.averageTime = averageTime
            self.qualityScore = qualityScore
            self.lastUpdate = lastUpdate
        }
    }
    
    public struct StreakData: Codable {
        public let currentStreak: Int
        public let longestStreak: Int
        public let lastUpdate: Date
        
        public init(currentStreak: Int, longestStreak: Int, lastUpdate: Date) {
            self.currentStreak = currentStreak
            self.longestStreak = longestStreak
            self.lastUpdate = lastUpdate
        }
    }
    
    public struct BuildingStatistics: Codable {
        public let buildingId: String
        public let totalTasks: Int
        public let completedTasks: Int
        public let completionRate: Double
        public let averageTaskTime: TimeInterval
        public let lastUpdated: Date
        
        public init(buildingId: String = "", totalTasks: Int, completedTasks: Int, completionRate: Double, averageTaskTime: TimeInterval = 3600, lastUpdated: Date = Date()) {
            self.buildingId = buildingId
            self.totalTasks = totalTasks
            self.completedTasks = completedTasks
            self.completionRate = completionRate
            self.averageTaskTime = averageTaskTime
            self.lastUpdated = lastUpdated
        }
        
        // Legacy constructor for compatibility
        public init(completionRate: Double, totalTasks: Int, completedTasks: Int) {
            self.init(totalTasks: totalTasks, completedTasks: completedTasks, completionRate: completionRate)
        }
    }
    
    public struct BuildingInsight: Identifiable, Codable {
        public let id: String
        public let buildingId: String
        public let title: String
        public let description: String
        public let type: String
        public let priority: Int
        public let actionRequired: Bool
        public let createdDate: Date
        
        public init(id: String, buildingId: String = "", title: String, description: String, type: String = "info", priority: Int, actionRequired: Bool = false, createdDate: Date = Date()) {
            self.id = id
            self.buildingId = buildingId
            self.title = title
            self.description = description
            self.type = type
            self.priority = priority
            self.actionRequired = actionRequired
            self.createdDate = createdDate
        }
        
        // Legacy constructor for compatibility
        public init(id: String, title: String, description: String, priority: Int) {
            self.init(id: id, title: title, description: description, priority: priority)
        }
    }
    
    // MARK: - Additional Required Types
    public struct WorkerRoutineSummary: Codable {
        public let workerId: String
        public let date: Date
        public let totalTasks: Int
        public let completedTasks: Int
        public let totalHours: Double
        public let efficiency: Double
        
        public init(workerId: String, date: Date, totalTasks: Int, completedTasks: Int, totalHours: Double, efficiency: Double) {
            self.workerId = workerId
            self.date = date
            self.totalTasks = totalTasks
            self.completedTasks = completedTasks
            self.totalHours = totalHours
            self.efficiency = efficiency
        }
    }
    
    public struct WorkerDailyRoute: Codable {
        public let workerId: String
        public let date: Date
        public let stops: [RouteStop]
        public let totalDistance: Double
        public let estimatedTime: TimeInterval
        
        public init(workerId: String, date: Date, stops: [RouteStop], totalDistance: Double, estimatedTime: TimeInterval) {
            self.workerId = workerId
            self.date = date
            self.stops = stops
            self.totalDistance = totalDistance
            self.estimatedTime = estimatedTime
        }
    }
    
    public struct RouteOptimization: Codable {
        public let originalRoute: [RouteStop]
        public let optimizedRoute: [RouteStop]
        public let timeSaved: TimeInterval
        public let distanceSaved: Double
        
        public init(originalRoute: [RouteStop], optimizedRoute: [RouteStop], timeSaved: TimeInterval, distanceSaved: Double) {
            self.originalRoute = originalRoute
            self.optimizedRoute = optimizedRoute
            self.timeSaved = timeSaved
            self.distanceSaved = distanceSaved
        }
    }
    
    public struct ScheduleConflict: Codable {
        public let id: String
        public let workerId: String
        public let conflictingTaskIds: [String]
        public let conflictType: String
        public let severity: String
        
        public init(id: String, workerId: String, conflictingTaskIds: [String], conflictType: String, severity: String) {
            self.id = id
            self.workerId = workerId
            self.conflictingTaskIds = conflictingTaskIds
            self.conflictType = conflictType
            self.severity = severity
        }
    }
    
    public struct RouteStop: Identifiable, Codable {
        public let id: String
        public let location: NamedCoordinate
        public let taskId: String
        public let estimatedDuration: TimeInterval
        public let arrivalTime: Date?
        public let departureTime: Date?
        
        public init(id: String, location: NamedCoordinate, taskId: String, estimatedDuration: TimeInterval, arrivalTime: Date?, departureTime: Date?) {
            self.id = id
            self.location = location
            self.taskId = taskId
            self.estimatedDuration = estimatedDuration
            self.arrivalTime = arrivalTime
            self.departureTime = departureTime
        }
    }
    
    public struct MaintenanceRecord: Identifiable, Codable {
        public let id: String
        public let taskId: String
        public let buildingId: String
        public let workerId: String
        public let completedDate: Date
        public let hoursSpent: Double
        public let notes: String?
        public let photos: [String]
        
        public init(id: String, taskId: String, buildingId: String, workerId: String, completedDate: Date, hoursSpent: Double, notes: String?, photos: [String]) {
            self.id = id
            self.taskId = taskId
            self.buildingId = buildingId
            self.workerId = workerId
            self.completedDate = completedDate
            self.hoursSpent = hoursSpent
            self.notes = notes
            self.photos = photos
        }
    }
    
    public struct TaskCompletionRecord: Identifiable, Codable {
        public let id: String
        public let taskId: String
        public let workerId: String
        public let completedAt: Date
        public let photosUploaded: [Data]
        public let notes: String
        public let verificationStatus: VerificationStatus
        
        public init(id: String, taskId: String, workerId: String, completedAt: Date, photosUploaded: [Data], notes: String, verificationStatus: VerificationStatus) {
            self.id = id
            self.taskId = taskId
            self.workerId = workerId
            self.completedAt = completedAt
            self.photosUploaded = photosUploaded
            self.notes = notes
            self.verificationStatus = verificationStatus
        }
    }
    
    public struct TaskEvidence: Codable {
        public let photos: [Data]
        public let timestamp: Date
        public let location: CLLocationCoordinate2D?
        public let notes: String?
        
        public init(photos: [Data], timestamp: Date, location: CLLocationCoordinate2D?, notes: String?) {
            self.photos = photos
            self.timestamp = timestamp
            self.location = location
            self.notes = notes
        }
        
        // Custom Codable implementation to handle CLLocationCoordinate2D
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            photos = try container.decode([Data].self, forKey: .photos)
            timestamp = try container.decode(Date.self, forKey: .timestamp)
            notes = try container.decodeIfPresent(String.self, forKey: .notes)
            
            if let latitude = try container.decodeIfPresent(Double.self, forKey: .latitude),
               let longitude = try container.decodeIfPresent(Double.self, forKey: .longitude) {
                location = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)
            } else {
                location = nil
            }
        }
        
        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(photos, forKey: .photos)
            try container.encode(timestamp, forKey: .timestamp)
            try container.encodeIfPresent(notes, forKey: .notes)
            
            if let location = location {
                try container.encode(location.latitude, forKey: .latitude)
                try container.encode(location.longitude, forKey: .longitude)
            }
        }
        
        private enum CodingKeys: String, CodingKey {
            case photos, timestamp, notes, latitude, longitude
        }
    }
    
    // MARK: - AI Types
    public enum AIScenario: String, Codable, CaseIterable {
        case routineIncomplete = "routineIncomplete"
        case pendingTasks = "pendingTasks"
        case missingPhoto = "missingPhoto"
        case clockOutReminder = "clockOutReminder"
        case weatherAlert = "weatherAlert"
        case buildingArrival = "buildingArrival"
        case taskCompletion = "taskCompletion"
        case inventoryLow = "inventoryLow"
    }
    
    public struct AISuggestion: Identifiable, Codable {
        public let id: String
        public let title: String
        public let description: String
        public let actionType: String
        public let priority: Int
        public let createdAt: Date
        
        public init(id: String, title: String, description: String, actionType: String, priority: Int, createdAt: Date) {
            self.id = id
            self.title = title
            self.description = description
            self.actionType = actionType
            self.priority = priority
            self.createdAt = createdAt
        }
    }
    
    public struct AIScenarioData: Codable {
        public let scenario: AIScenario
        public let context: [String: String]
        public let suggestions: [AISuggestion]
        public let priority: Int
        public let timestamp: Date
        
        public init(scenario: AIScenario, context: [String: String], suggestions: [AISuggestion], priority: Int, timestamp: Date) {
            self.scenario = scenario
            self.context = context
            self.suggestions = suggestions
            self.priority = priority
            self.timestamp = timestamp
        }
    }
    
    public struct WeatherImpact: Codable {
        public let condition: WeatherCondition
        public let temperature: Double
        public let affectedTasks: [ContextualTask]
        public let recommendation: String
        
        public init(condition: WeatherCondition, temperature: Double, affectedTasks: [ContextualTask], recommendation: String) {
            self.condition = condition
            self.temperature = temperature
            self.affectedTasks = affectedTasks
            self.recommendation = recommendation
        }
    }
    
    public enum DataHealthStatus: Codable {
        case healthy
        case warning(String)
        case error(String)
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(String.self, forKey: .type)
            
            switch type {
            case "healthy":
                self = .healthy
            case "warning":
                let message = try container.decode(String.self, forKey: .message)
                self = .warning(message)
            case "error":
                let message = try container.decode(String.self, forKey: .message)
                self = .error(message)
            default:
                self = .healthy
            }
        }
        
        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            
            switch self {
            case .healthy:
                try container.encode("healthy", forKey: .type)
            case .warning(let message):
                try container.encode("warning", forKey: .type)
                try container.encode(message, forKey: .message)
            case .error(let message):
                try container.encode("error", forKey: .type)
                try container.encode(message, forKey: .message)
            }
        }
        
        private enum CodingKeys: String, CodingKey {
            case type, message
        }
    }
    
    public enum BuildingTab: String, CaseIterable {
        case overview = "Overview"
        case tasks = "Tasks"
        case workers = "Workers"
        case inventory = "Inventory"
        case analytics = "Analytics"
    }
    
    public struct ExportProgress: Codable {
        public let percentage: Double
        public let currentStep: String
        public let isComplete: Bool
        
        public init(percentage: Double, currentStep: String, isComplete: Bool) {
            self.percentage = percentage
            self.currentStep = currentStep
            self.isComplete = isComplete
        }
        
        public var calculatedPercentage: Double {
            min(max(percentage, 0), 100)
        }
    }
    
    public enum ImportError: LocalizedError {
        case noSQLiteManager
        case invalidData(String)
        
        public var errorDescription: String? {
            switch self {
            case .noSQLiteManager:
                return "SQLiteManager not initialized"
            case .invalidData(let message):
                return "Invalid data: \(message)"
            }
        }
    }
}

// MARK: - Clean Type Aliases
public typealias NamedCoordinate = FrancoSphere.NamedCoordinate
public typealias WeatherCondition = FrancoSphere.WeatherCondition
public typealias WeatherData = FrancoSphere.WeatherData
public typealias OutdoorWorkRisk = FrancoSphere.OutdoorWorkRisk
public typealias TaskCategory = FrancoSphere.TaskCategory
public typealias TaskUrgency = FrancoSphere.TaskUrgency
public typealias TaskRecurrence = FrancoSphere.TaskRecurrence
public typealias VerificationStatus = FrancoSphere.VerificationStatus
public typealias MaintenanceTask = FrancoSphere.MaintenanceTask
public typealias WorkerSkill = FrancoSphere.WorkerSkill
public typealias UserRole = FrancoSphere.UserRole
public typealias WorkerProfile = FrancoSphere.WorkerProfile
public typealias WorkerAssignment = FrancoSphere.WorkerAssignment
public typealias InventoryCategory = FrancoSphere.InventoryCategory
public typealias RestockStatus = FrancoSphere.RestockStatus
public typealias InventoryItem = FrancoSphere.InventoryItem
public typealias ContextualTask = FrancoSphere.ContextualTask
public typealias WorkerRoutineSummary = FrancoSphere.WorkerRoutineSummary
public typealias WorkerDailyRoute = FrancoSphere.WorkerDailyRoute
public typealias RouteOptimization = FrancoSphere.RouteOptimization
public typealias ScheduleConflict = FrancoSphere.ScheduleConflict
public typealias RouteStop = FrancoSphere.RouteStop
public typealias BuildingInsight = FrancoSphere.BuildingInsight
public typealias BuildingTab = FrancoSphere.BuildingTab
public typealias BuildingStatus = FrancoSphere.BuildingStatus
public typealias TaskTrends = FrancoSphere.TaskTrends
public typealias PerformanceMetrics = FrancoSphere.PerformanceMetrics
public typealias StreakData = FrancoSphere.StreakData
public typealias TrendDirection = FrancoSphere.TrendDirection
public typealias BuildingStatistics = FrancoSphere.BuildingStatistics
public typealias TaskEvidence = FrancoSphere.TaskEvidence
public typealias TaskProgress = FrancoSphere.TaskProgress
public typealias AIScenario = FrancoSphere.AIScenario
public typealias AISuggestion = FrancoSphere.AISuggestion
public typealias AIScenarioData = FrancoSphere.AIScenarioData
public typealias WeatherImpact = FrancoSphere.WeatherImpact
public typealias DataHealthStatus = FrancoSphere.DataHealthStatus
public typealias MaintenanceRecord = FrancoSphere.MaintenanceRecord
public typealias TaskCompletionRecord = FrancoSphere.TaskCompletionRecord
public typealias ExportProgress = FrancoSphere.ExportProgress
public typealias ImportError = FrancoSphere.ImportError

// Legacy compatibility
public typealias FSTaskItem = ContextualTask
public typealias DetailedWorker = WorkerProfile
