import Foundation
import SwiftUI
import CoreLocation

public enum FrancoSphere {
    
    public struct NamedCoordinate: Identifiable, Codable, Hashable {
        public let id: String
        public let name: String
        public let latitude: Double
        public let longitude: Double
        public let imageAssetName: String
        
        public init(id: String, name: String, latitude: Double, longitude: Double, imageAssetName: String) {
            self.id = id
            self.name = name
            self.latitude = latitude
            self.longitude = longitude
            self.imageAssetName = imageAssetName
        }
    }
    
    public enum WeatherCondition: String, CaseIterable, Codable {
        case clear = "clear"
        case cloudy = "cloudy"
        case rain = "rain"
        case snow = "snow"
        case fog = "fog"
        case storm = "storm"
    }
    
    public struct WeatherData: Codable, Hashable {
        public let temperature: Double
        public let condition: WeatherCondition
        public let humidity: Double
        public let windSpeed: Double
        public let timestamp: Date
        
        public init(temperature: Double, condition: WeatherCondition, humidity: Double, windSpeed: Double, timestamp: Date) {
            self.temperature = temperature
            self.condition = condition
            self.humidity = humidity
            self.windSpeed = windSpeed
            self.timestamp = timestamp
        }
    }
    
    public enum TaskCategory: String, CaseIterable, Codable {
        case maintenance = "Maintenance"
        case cleaning = "Cleaning"
        case repair = "Repair"
        case inspection = "Inspection"
        case sanitation = "Sanitation"
    }
    
    public enum TaskUrgency: String, CaseIterable, Codable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case urgent = "Urgent"
    }
    
    public enum TaskRecurrence: String, CaseIterable, Codable {
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
        case yearly = "Yearly"
        case oneOff = "One-off"
    }
    
    public struct MaintenanceTask: Identifiable, Codable {
        public let id: String
        public let name: String
        public let buildingID: String
        public let category: TaskCategory
        public let urgency: TaskUrgency
        public let recurrence: TaskRecurrence
        public let isComplete: Bool
        public let dueDate: Date
        
        public init(id: String, name: String, buildingID: String, category: TaskCategory, urgency: TaskUrgency, recurrence: TaskRecurrence, isComplete: Bool, dueDate: Date) {
            self.id = id
            self.name = name
            self.buildingID = buildingID
            self.category = category
            self.urgency = urgency
            self.recurrence = recurrence
            self.isComplete = isComplete
            self.dueDate = dueDate
        }
    }
    
    public enum VerificationStatus: String, CaseIterable, Codable {
        case pending = "Pending"
        case verified = "Verified"
        case failed = "Failed"
    }
    
    public enum WorkerSkill: String, CaseIterable, Codable {
        case basic = "Basic"
        case intermediate = "Intermediate"
        case advanced = "Advanced"
        case expert = "Expert"
    }
    
    public enum UserRole: String, CaseIterable, Codable {
        case worker = "Worker"
        case supervisor = "Supervisor"
        case admin = "Admin"
    }
    
    public struct WorkerProfile: Identifiable, Codable {
        public let id: String
        public let name: String
        public let email: String
        public let role: UserRole
        public let skillLevel: WorkerSkill
        
        public init(id: String, name: String, email: String, role: UserRole, skillLevel: WorkerSkill) {
            self.id = id
            self.name = name
            self.email = email
            self.role = role
            self.skillLevel = skillLevel
        }
    }
    
    public enum InventoryCategory: String, CaseIterable, Codable {
        case cleaning = "Cleaning"
        case maintenance = "Maintenance"
        case safety = "Safety"
        case office = "Office"
        case other = "Other"
    }
    
    public enum RestockStatus: String, CaseIterable, Codable {
        case inStock = "In Stock"
        case lowStock = "Low Stock"
        case outOfStock = "Out of Stock"
        case ordered = "Ordered"
    }
    
    public struct InventoryItem: Identifiable, Codable {
        public let id: String
        public let name: String
        public let category: InventoryCategory
        public let quantity: Int
        public let status: RestockStatus
        
        public init(id: String, name: String, category: InventoryCategory, quantity: Int, status: RestockStatus) {
            self.id = id
            self.name = name
            self.category = category
            self.quantity = quantity
            self.status = status
        }
    }
    
    public struct TaskProgress {
        public let completed: Int
        public let total: Int
        public let remaining: Int
        public let percentage: Double
        public let overdueTasks: Int
        public let averageCompletionTime: Double
        public let onTimeCompletionRate: Double
        
        public init(completed: Int, total: Int, remaining: Int, percentage: Double, overdueTasks: Int, averageCompletionTime: Double = 0, onTimeCompletionRate: Double = 0) {
            self.completed = completed
            self.total = total
            self.remaining = remaining
            self.percentage = percentage
            self.overdueTasks = overdueTasks
            self.averageCompletionTime = averageCompletionTime
            self.onTimeCompletionRate = onTimeCompletionRate
        }
    }
    
    public enum DataHealthStatus: Equatable {
        case unknown
        case healthy
        case warning([String])
        case critical([String])
    }
    
    public struct AIScenario: Identifiable {
        public let id: String
        public let title: String
        public let description: String
        public let suggestions: [AISuggestion]
        
        public init(id: String, title: String, description: String, suggestions: [AISuggestion]) {
            self.id = id
            self.title = title
            self.description = description
            self.suggestions = suggestions
        }
    }
    
    public struct AISuggestion: Identifiable {
        public let id: String
        public let text: String
        public let priority: TaskUrgency
        
        public init(id: String, text: String, priority: TaskUrgency) {
            self.id = id
            self.text = text
            self.priority = priority
        }
    }
    
    public struct AIScenarioData {
        public let scenarios: [AIScenario]
        public let lastUpdated: Date
        
        public init(scenarios: [AIScenario], lastUpdated: Date) {
            self.scenarios = scenarios
            self.lastUpdated = lastUpdated
        }
    }
    
    public struct BuildingStatus {
        public let buildingId: String
        public let completedTasks: Int
        public let pendingTasks: Int
        public let overdueTasks: Int
        public let lastUpdated: Date
        
        public init(buildingId: String, completedTasks: Int, pendingTasks: Int, overdueTasks: Int, lastUpdated: Date) {
            self.buildingId = buildingId
            self.completedTasks = completedTasks
            self.pendingTasks = pendingTasks
            self.overdueTasks = overdueTasks
            self.lastUpdated = lastUpdated
        }
    }
    
    public struct TaskEvidence {
        public let photos: [Data]
        public let timestamp: Date
        public let location: CLLocation?
        public let notes: String?
        
        public init(photos: [Data], timestamp: Date, location: CLLocation?, notes: String?) {
            self.photos = photos
            self.timestamp = timestamp
            self.location = location
            self.notes = notes
        }
    }
    
    public struct TaskCompletionInfo {
        public let completedAt: Date
        public let completedBy: String
        public let evidence: TaskEvidence?
        
        public init(completedAt: Date, completedBy: String, evidence: TaskEvidence?) {
            self.completedAt = completedAt
            self.completedBy = completedBy
            self.evidence = evidence
        }
    }
    
    public struct TaskCompletionRecord: Identifiable, Codable {
        public let id: String
        public let taskId: String
        public let workerId: String
        public let completedAt: Date
        public let photoPath: String?
        public let notes: String?
        
        public init(id: String, taskId: String, workerId: String, completedAt: Date, photoPath: String?, notes: String?) {
            self.id = id
            self.taskId = taskId
            self.workerId = workerId
            self.completedAt = completedAt
            self.photoPath = photoPath
            self.notes = notes
        }
    }
    
    public struct WeatherImpact {
        public let condition: WeatherCondition
        public let temperature: Double
        public let affectedTasks: [String]
        public let recommendation: String
        
        public init(condition: WeatherCondition, temperature: Double, affectedTasks: [String], recommendation: String) {
            self.condition = condition
            self.temperature = temperature
            self.affectedTasks = affectedTasks
            self.recommendation = recommendation
        }
    }
    
    public struct Worker {
        public let workerId: String
        public let name: String
        public let email: String
        public let role: String
        public let isActive: Bool
        
        public init(workerId: String, name: String, email: String, role: String, isActive: Bool) {
            self.workerId = workerId
            self.name = name
            self.email = email
            self.role = role
            self.isActive = isActive
        }
    }
    
    public struct WorkerShift {
        public let id: String
        public let workerId: String
        public let startTime: Date
        public let endTime: Date?
        public let buildingId: String
        
        public init(id: String, workerId: String, startTime: Date, endTime: Date?, buildingId: String) {
            self.id = id
            self.workerId = workerId
            self.startTime = startTime
            self.endTime = endTime
            self.buildingId = buildingId
        }
    }
    
    public enum ClockInStatus {
        case clockedIn
        case clockedOut
        case onBreak
    }
    
    public enum BuildingTab: String, CaseIterable {
        case overview = "Overview"
        case tasks = "Tasks"
        case workers = "Workers"
        case stats = "Stats"
    }
    
    public struct BuildingStatistics {
        public let completionRate: Double
        public let tasksCompleted: Int
        public let tasksRemaining: Int
        public let averageCompletionTime: Double
        
        public init(completionRate: Double, tasksCompleted: Int, tasksRemaining: Int, averageCompletionTime: Double) {
            self.completionRate = completionRate
            self.tasksCompleted = tasksCompleted
            self.tasksRemaining = tasksRemaining
            self.averageCompletionTime = averageCompletionTime
        }
    }
    
    public struct BuildingInsight {
        public let title: String
        public let description: String
        public let type: InsightType
        
        public enum InsightType {
            case positive
            case warning
            case critical
        }
        
        public init(title: String, description: String, type: InsightType) {
            self.title = title
            self.description = description
            self.type = type
        }
    }
    
    public struct TaskCompletionStats {
        public let todayCompleted: Int
        public let weekCompleted: Int
        public let monthCompleted: Int
        public let averageTime: Double
        
        public init(todayCompleted: Int, weekCompleted: Int, monthCompleted: Int, averageTime: Double) {
            self.todayCompleted = todayCompleted
            self.weekCompleted = weekCompleted
            self.monthCompleted = monthCompleted
            self.averageTime = averageTime
        }
    }
    
    public enum Timeframe: String, CaseIterable {
        case today = "Today"
        case week = "Week"
        case month = "Month"
        case year = "Year"
    }
    
    public struct DayProgress {
        public let date: Date
        public let completed: Int
        public let total: Int
        public let percentage: Double
        
        public init(date: Date, completed: Int, total: Int, percentage: Double) {
            self.date = date
            self.completed = completed
            self.total = total
            self.percentage = percentage
        }
    }
    
    public struct TaskTrends {
        public let weeklyCompletion: [DayProgress]
        public let categoryBreakdown: [CategoryProgress]
        public let trend: TrendDirection
        
        public enum TrendDirection {
            case improving
            case declining
            case stable
        }
        
        public init(weeklyCompletion: [DayProgress], categoryBreakdown: [CategoryProgress], trend: TrendDirection) {
            self.weeklyCompletion = weeklyCompletion
            self.categoryBreakdown = categoryBreakdown
            self.trend = trend
        }
    }
    
    public struct CategoryProgress {
        public let category: String
        public let completed: Int
        public let total: Int
        public let percentage: Double
        
        public init(category: String, completed: Int, total: Int, percentage: Double) {
            self.category = category
            self.completed = completed
            self.total = total
            self.percentage = percentage
        }
    }
    
    public struct PerformanceMetrics {
        public let efficiency: Double
        public let quality: Double
        public let speed: Double
        public let consistency: Double
        
        public init(efficiency: Double, quality: Double, speed: Double, consistency: Double) {
            self.efficiency = efficiency
            self.quality = quality
            self.speed = speed
            self.consistency = consistency
        }
    }
    
    public enum ProductivityTrend {
        case increasing
        case decreasing
        case stable
        case insufficient_data
    }
    
    public struct StreakData {
        public let currentStreak: Int
        public let longestStreak: Int
        public let lastCompletionDate: Date?
        
        public init(currentStreak: Int, longestStreak: Int, lastCompletionDate: Date? = nil) {
            self.currentStreak = currentStreak
            self.longestStreak = longestStreak
            self.lastCompletionDate = lastCompletionDate
        }
    }
    
    public struct MaintenanceRecord: Identifiable, Codable {
        public let id: String
        public let taskId: String
        public let buildingId: String
        public let description: String
        public let completedDate: Date
        public let performedBy: String
        
        public init(id: String, taskId: String, buildingId: String, description: String, completedDate: Date, performedBy: String) {
            self.id = id
            self.taskId = taskId
            self.buildingId = buildingId
            self.description = description
            self.completedDate = completedDate
            self.performedBy = performedBy
        }
    }
    
    public struct WorkerAssignment: Identifiable, Codable {
        public let id: String
        public let workerId: String
        public let buildingId: String
        public let startDate: Date
        public let endDate: Date?
        
        public init(id: String, workerId: String, buildingId: String, startDate: Date, endDate: Date? = nil) {
            self.id = id
            self.workerId = workerId
            self.buildingId = buildingId
            self.startDate = startDate
            self.endDate = endDate
        }
    }
    
    public struct WorkerRoutineSummary {
        public let workerId: String
        public let totalTasks: Int
        public let completedTasks: Int
        public let estimatedDuration: TimeInterval
        
        public init(workerId: String, totalTasks: Int, completedTasks: Int, estimatedDuration: TimeInterval) {
            self.workerId = workerId
            self.totalTasks = totalTasks
            self.completedTasks = completedTasks
            self.estimatedDuration = estimatedDuration
        }
    }
    
    public struct WorkerDailyRoute {
        public let workerId: String
        public let date: Date
        public let stops: [RouteStop]
        public let estimatedDuration: TimeInterval
        
        public init(workerId: String, date: Date, stops: [RouteStop], estimatedDuration: TimeInterval) {
            self.workerId = workerId
            self.date = date
            self.stops = stops
            self.estimatedDuration = estimatedDuration
        }
    }
    
    public struct RouteStop: Identifiable {
        public let id: String
        public let buildingId: String
        public let estimatedArrival: Date
        public let tasks: [MaintenanceTask]
        
        public init(id: String, buildingId: String, estimatedArrival: Date, tasks: [MaintenanceTask]) {
            self.id = id
            self.buildingId = buildingId
            self.estimatedArrival = estimatedArrival
            self.tasks = tasks
        }
    }
    
    public struct RouteOptimization {
        public let originalDuration: TimeInterval
        public let optimizedDuration: TimeInterval
        public let savings: TimeInterval
        
        public init(originalDuration: TimeInterval, optimizedDuration: TimeInterval, savings: TimeInterval) {
            self.originalDuration = originalDuration
            self.optimizedDuration = optimizedDuration
            self.savings = savings
        }
    }
    
    public struct ScheduleConflict {
        public let id: String
        public let description: String
        public let severity: ConflictSeverity
        
        public enum ConflictSeverity {
            case low, medium, high
        }
        
        public init(id: String, description: String, severity: ConflictSeverity) {
            self.id = id
            self.description = description
            self.severity = severity
        }
    }
    
    public struct FSTaskItem: Identifiable {
        public let id: String
        public let name: String
        public let buildingId: String
        public let status: String
        
        public init(id: String, name: String, buildingId: String, status: String) {
            self.id = id
            self.name = name
            self.buildingId = buildingId
            self.status = status
        }
    }

    public enum OutdoorWorkRisk {
        case low, medium, high, extreme
        
        public var color: Color {
            switch self {
            case .low: return .green
            case .medium: return .yellow
            case .high: return .orange
            case .extreme: return .red
            }
        }
        
        public var description: String {
            switch self {
            case .low: return "Safe for outdoor work"
            case .medium: return "Use caution outdoors"
            case .high: return "Limited outdoor work"
            case .extreme: return "Avoid outdoor work"
            }
        }
    }
}

public typealias NamedCoordinate = FrancoSphere.NamedCoordinate
public typealias WeatherCondition = FrancoSphere.WeatherCondition
public typealias WeatherData = FrancoSphere.WeatherData
public typealias TaskCategory = FrancoSphere.TaskCategory
public typealias TaskUrgency = FrancoSphere.TaskUrgency
public typealias TaskRecurrence = FrancoSphere.TaskRecurrence
public typealias MaintenanceTask = FrancoSphere.MaintenanceTask
public typealias VerificationStatus = FrancoSphere.VerificationStatus
public typealias WorkerSkill = FrancoSphere.WorkerSkill
public typealias UserRole = FrancoSphere.UserRole
public typealias WorkerProfile = FrancoSphere.WorkerProfile
public typealias InventoryCategory = FrancoSphere.InventoryCategory
public typealias RestockStatus = FrancoSphere.RestockStatus
public typealias InventoryItem = FrancoSphere.InventoryItem
public typealias TaskProgress = FrancoSphere.TaskProgress
public typealias DataHealthStatus = FrancoSphere.DataHealthStatus
public typealias AIScenario = FrancoSphere.AIScenario
public typealias AISuggestion = FrancoSphere.AISuggestion
public typealias AIScenarioData = FrancoSphere.AIScenarioData
public typealias BuildingStatus = FrancoSphere.BuildingStatus
public typealias TaskEvidence = FrancoSphere.TaskEvidence
public typealias TaskCompletionInfo = FrancoSphere.TaskCompletionInfo
public typealias TaskCompletionRecord = FrancoSphere.TaskCompletionRecord
public typealias WeatherImpact = FrancoSphere.WeatherImpact
public typealias WorkerShift = FrancoSphere.WorkerShift
public typealias ClockInStatus = FrancoSphere.ClockInStatus
public typealias BuildingTab = FrancoSphere.BuildingTab
public typealias BuildingStatistics = FrancoSphere.BuildingStatistics
public typealias BuildingInsight = FrancoSphere.BuildingInsight
public typealias TaskCompletionStats = FrancoSphere.TaskCompletionStats
public typealias Timeframe = FrancoSphere.Timeframe
public typealias DayProgress = FrancoSphere.DayProgress
public typealias TaskTrends = FrancoSphere.TaskTrends
public typealias CategoryProgress = FrancoSphere.CategoryProgress
public typealias PerformanceMetrics = FrancoSphere.PerformanceMetrics
public typealias ProductivityTrend = FrancoSphere.ProductivityTrend
public typealias StreakData = FrancoSphere.StreakData
public typealias MaintenanceRecord = FrancoSphere.MaintenanceRecord
public typealias WorkerAssignment = FrancoSphere.WorkerAssignment
public typealias WorkerRoutineSummary = FrancoSphere.WorkerRoutineSummary
public typealias WorkerDailyRoute = FrancoSphere.WorkerDailyRoute
public typealias RouteStop = FrancoSphere.RouteStop
public typealias RouteOptimization = FrancoSphere.RouteOptimization
public typealias ScheduleConflict = FrancoSphere.ScheduleConflict
public typealias FSTaskItem = FrancoSphere.FSTaskItem
public typealias TSTaskEvidence = TaskEvidence
public typealias OutdoorWorkRisk = FrancoSphere.OutdoorWorkRisk}
