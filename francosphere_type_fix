#!/bin/bash

# Fix missing types and manager references across FrancoSphere
# Address MaintenanceTask, TaskUrgency, TaskCategory, WeatherManager issues

XCODE_PATH="/Volumes/FastSSD/Xcode"

echo "🔧 Fixing missing types and manager references"
echo "==============================================="

cd "$XCODE_PATH" || exit 1

# Step 1: Create missing core types in Models/TaskTypes.swift
echo "🏗️ Step 1: Creating missing core types..."

cat > "Models/TaskTypes.swift" << 'INNER_EOF'
//
//  TaskTypes.swift
//  FrancoSphere
//
//  ✅ Defines all missing task-related types
//

import Foundation

// MARK: - MaintenanceTask (Core task type)
struct MaintenanceTask: Identifiable, Codable {
    let id: String
    let name: String
    let buildingId: String
    let buildingName: String
    let category: TaskCategory
    let urgency: TaskUrgency
    let recurrence: TaskRecurrence
    let startTime: String
    let endTime: String
    let skillLevel: String
    let status: String
    let assignedWorkerName: String
    let notes: String?
    let estimatedDuration: TimeInterval
    let completedAt: Date?
    
    init(id: String = UUID().uuidString,
         name: String,
         buildingId: String,
         buildingName: String,
         category: TaskCategory,
         urgency: TaskUrgency = .medium,
         recurrence: TaskRecurrence = .daily,
         startTime: String,
         endTime: String,
         skillLevel: String = "Basic",
         status: String = "pending",
         assignedWorkerName: String,
         notes: String? = nil,
         estimatedDuration: TimeInterval = 3600,
         completedAt: Date? = nil) {
        
        self.id = id
        self.name = name
        self.buildingId = buildingId
        self.buildingName = buildingName
        self.category = category
        self.urgency = urgency
        self.recurrence = recurrence
        self.startTime = startTime
        self.endTime = endTime
        self.skillLevel = skillLevel
        self.status = status
        self.assignedWorkerName = assignedWorkerName
        self.notes = notes
        self.estimatedDuration = estimatedDuration
        self.completedAt = completedAt
    }
}

// MARK: - TaskCategory
enum TaskCategory: String, CaseIterable, Codable {
    case cleaning = "Cleaning"
    case sanitation = "Sanitation"
    case maintenance = "Maintenance"
    case inspection = "Inspection"
    case delivery = "Delivery"
    case dsny = "DSNY"
    case emergency = "Emergency"
    case routine = "Routine"
    
    var icon: String {
        switch self {
        case .cleaning: return "🧹"
        case .sanitation: return "🗑️"
        case .maintenance: return "🔧"
        case .inspection: return "🔍"
        case .delivery: return "📦"
        case .dsny: return "🚛"
        case .emergency: return "🚨"
        case .routine: return "📋"
        }
    }
    
    var color: String {
        switch self {
        case .cleaning: return "blue"
        case .sanitation: return "green"
        case .maintenance: return "orange"
        case .inspection: return "purple"
        case .delivery: return "brown"
        case .dsny: return "yellow"
        case .emergency: return "red"
        case .routine: return "gray"
        }
    }
}

// MARK: - TaskUrgency
enum TaskUrgency: String, CaseIterable, Codable {
    case low = "Low"
    case medium = "Medium"
    case high = "High"
    case critical = "Critical"
    
    var priority: Int {
        switch self {
        case .low: return 1
        case .medium: return 2
        case .high: return 3
        case .critical: return 4
        }
    }
    
    var color: String {
        switch self {
        case .low: return "green"
        case .medium: return "yellow"
        case .high: return "orange"
        case .critical: return "red"
        }
    }
}

// MARK: - TaskRecurrence
enum TaskRecurrence: String, CaseIterable, Codable {
    case daily = "Daily"
    case weekly = "Weekly"
    case biweekly = "Bi-weekly"
    case monthly = "Monthly"
    case quarterly = "Quarterly"
    case yearly = "Yearly"
    case oneOff = "One-off"
    
    var shortForm: String {
        switch self {
        case .daily: return "D"
        case .weekly: return "W"
        case .biweekly: return "BW"
        case .monthly: return "M"
        case .quarterly: return "Q"
        case .yearly: return "Y"
        case .oneOff: return "1x"
        }
    }
}

// MARK: - MaintenanceTask Extensions
extension MaintenanceTask {
    
    // Convert from ContextualTask
    init(from contextualTask: ContextualTask) {
        self.init(
            id: contextualTask.id,
            name: contextualTask.name,
            buildingId: contextualTask.buildingId,
            buildingName: contextualTask.buildingName,
            category: TaskCategory(rawValue: contextualTask.category) ?? .routine,
            urgency: TaskUrgency(rawValue: contextualTask.urgencyLevel) ?? .medium,
            recurrence: TaskRecurrence(rawValue: contextualTask.recurrence) ?? .daily,
            startTime: contextualTask.startTime,
            endTime: contextualTask.endTime,
            skillLevel: contextualTask.skillLevel,
            status: contextualTask.status,
            assignedWorkerName: contextualTask.assignedWorkerName
        )
    }
    
    // Convert to ContextualTask
    func toContextualTask() -> ContextualTask {
        return ContextualTask(
            id: id,
            name: name,
            buildingId: buildingId,
            buildingName: buildingName,
            category: category.rawValue,
            startTime: startTime,
            endTime: endTime,
            recurrence: recurrence.rawValue,
            skillLevel: skillLevel,
            status: status,
            urgencyLevel: urgency.rawValue,
            assignedWorkerName: assignedWorkerName
        )
    }
}
INNER_EOF

echo "   ✅ TaskTypes.swift created with MaintenanceTask, TaskCategory, TaskUrgency, TaskRecurrence"

# Step 2: Create WeatherManager.swift
echo "🌤️ Step 2: Creating WeatherManager.swift..."

cat > "Managers/WeatherManager.swift" << 'INNER_EOF'
//
//  WeatherManager.swift
//  FrancoSphere
//
//  ✅ Weather management for task scheduling
//

import Foundation
import Combine

@MainActor
class WeatherManager: ObservableObject {
    static let shared = WeatherManager()
    
    @Published var currentWeather: FrancoSphere.WeatherData?
    @Published var isLoading = false
    @Published var error: Error?
    
    private var cancellables = Set<AnyCancellable>()
    private let updateInterval: TimeInterval = 1800 // 30 minutes
    
    private init() {
        startPeriodicUpdates()
    }
    
    func fetchCurrentWeather() async {
        isLoading = true
        error = nil
        
        do {
            // Simulate weather API call for NYC
            let weather = FrancoSphere.WeatherData(
                temperature: Double.random(in: 20...85),
                condition: FrancoSphere.WeatherCondition.allCases.randomElement() ?? .clear,
                humidity: Double.random(in: 30...90),
                windSpeed: Double.random(in: 0...25),
                timestamp: Date()
            )
            
            currentWeather = weather
            isLoading = false
            
        } catch {
            self.error = error
            isLoading = false
        }
    }
    
    func getWeatherImpactForTask(_ task: MaintenanceTask) -> WeatherImpact? {
        guard let weather = currentWeather else { return nil }
        
        // Determine if weather affects this task
        let isOutdoorTask = task.category == .cleaning || 
                           task.category == .sanitation ||
                           task.name.lowercased().contains("sidewalk") ||
                           task.name.lowercased().contains("hose")
        
        guard isOutdoorTask else { return nil }
        
        var impact = WeatherImpact.none
        var recommendation = "Normal conditions for outdoor work."
        
        switch weather.condition {
        case .rain:
            impact = .moderate
            recommendation = "Rain detected. Consider postponing sidewalk hosing and outdoor cleaning."
        case .snow:
            impact = .severe
            recommendation = "Snow conditions. Focus on snow removal and postpone non-essential outdoor tasks."
        default:
            if weather.temperature < 32 {
                impact = .moderate
                recommendation = "Freezing temperatures. Take precautions for outdoor work."
            } else if weather.temperature > 90 {
                impact = .moderate
                recommendation = "High temperature. Take frequent breaks and stay hydrated."
            } else if weather.windSpeed > 20 {
                impact = .mild
                recommendation = "High winds. Secure loose items during outdoor work."
            }
        }
        
        return WeatherImpact(
            level: impact,
            recommendation: recommendation,
            affectedCategories: isOutdoorTask ? [task.category] : []
        )
    }
    
    private func startPeriodicUpdates() {
        Timer.publish(every: updateInterval, on: .main, in: .common)
            .autoconnect()
            .sink { _ in
                Task {
                    await self.fetchCurrentWeather()
                }
            }
            .store(in: &cancellables)
        
        // Initial fetch
        Task {
            await fetchCurrentWeather()
        }
    }
}

// MARK: - Supporting Types

enum WeatherImpact {
    case none
    case mild
    case moderate
    case severe
    
    var color: String {
        switch self {
        case .none: return "green"
        case .mild: return "yellow"
        case .moderate: return "orange"
        case .severe: return "red"
        }
    }
}

struct WeatherImpact {
    let level: WeatherImpact
    let recommendation: String
    let affectedCategories: [TaskCategory]
}
INNER_EOF

echo "   ✅ WeatherManager.swift created"

# Step 3: Fix TaskService.swift to remove TSTaskProgress conflict
echo "🔧 Step 3: Fixing TaskService.swift TSTaskProgress conflict..."

if [ -f "Services/TaskService.swift" ]; then
    # Remove the conflicting TSTaskProgress typedef
    sed -i '' '/typealias TSTaskProgress/d' "Services/TaskService.swift"
    sed -i '' '/struct TSTaskProgress/,/^}/d' "Services/TaskService.swift"
    echo "   ✅ Removed TSTaskProgress conflict from TaskService.swift"
fi

# Step 4: Fix WorkerDashboardIntegration.swift (final version)
echo "🔧 Step 4: Fixing WorkerDashboardIntegration.swift (final version)..."

cat > "Services/WorkerDashboardIntegration.swift" << 'INNER_EOF'
//
//  WorkerDashboardIntegration.swift
//  FrancoSphere
//
//  ✅ FINAL VERSION - All compilation errors fixed
//

import Foundation
import SwiftUI
import Combine
import CoreLocation

@MainActor
class WorkerDashboardIntegration: ObservableObject {
    
    static let shared = WorkerDashboardIntegration()
    
    // Service Dependencies
    private let taskService = TaskService.shared
    private let workerService = WorkerService.shared
    private let buildingService = BuildingService.shared
    private let contextEngine = WorkerContextEngine.shared
    private let operationalManager = OperationalDataManager.shared
    
    // Published Properties
    @Published var dashboardData: DashboardData?
    @Published var isLoading = false
    @Published var error: Error?
    @Published var csvImportProgress: Double = 0.0
    @Published var lastRefresh: Date?
    
    // Private Properties
    private var refreshTimer: Timer?
    private var cancellables = Set<AnyCancellable>()
    
    private init() {
        setupReactiveBindings()
    }
    
    func loadDashboardData(for workerId: String) async {
        await MainActor.run {
            isLoading = true
            error = nil
        }
        
        do {
            let buildings = try await loadBuildingsForWorker(workerId)
            let tasks = try await loadTasksForWorker(workerId)
            let progress = await calculateTaskProgress(for: workerId)
            
            await MainActor.run {
                self.dashboardData = DashboardData(
                    workerId: workerId,
                    assignedBuildings: buildings,
                    todaysTasks: tasks,
                    taskProgress: progress,
                    lastUpdated: Date()
                )
                
                self.lastRefresh = Date()
                self.isLoading = false
            }
            
        } catch {
            await MainActor.run {
                self.error = error
                self.isLoading = false
            }
        }
    }
    
    func refreshDashboard() async {
        guard let currentData = dashboardData else { return }
        await loadDashboardData(for: currentData.workerId)
    }
    
    func updateTaskCompletion(_ taskId: String, buildingId: String) async {
        guard let workerId = dashboardData?.workerId else { return }
        
        do {
            let evidence = WDITaskEvidence(
                photos: [Data](),
                timestamp: Date(),
                location: CLLocation(latitude: 0, longitude: 0),
                notes: String?.none
            )
            
            try await taskService.completeTask(
                taskId,
                workerId: workerId,
                buildingId: buildingId,
                evidence: evidence
            )
            
            await contextEngine.updateTaskCompletion(
                workerId: workerId,
                buildingId: buildingId,
                taskName: ""
            )
            
            await refreshDashboard()
            
        } catch {
            await MainActor.run {
                self.error = error
            }
        }
    }
    
    private func loadBuildingsForWorker(_ workerId: String) async throws -> [FrancoSphere.NamedCoordinate] {
        return try await workerService.getAssignedBuildings(workerId)
    }
    
    private func loadTasksForWorker(_ workerId: String) async throws -> [ContextualTask] {
        return try await taskService.getTasks(for: workerId, date: Date())
    }
    
    private func calculateTaskProgress(for workerId: String) async -> WDITaskProgress {
        do {
            let progress = try await taskService.getTaskProgress(for: workerId)
            return WDITaskProgress(
                completed: progress.completed,
                total: progress.total,
                remaining: progress.remaining,
                percentage: progress.percentage,
                overdueTasks: progress.overdueTasks
            )
        } catch {
            return WDITaskProgress(
                completed: 0,
                total: 0,
                remaining: 0,
                percentage: 0,
                overdueTasks: 0
            )
        }
    }
    
    func ensureOperationalDataLoaded() async {
        do {
            let hasImported = await checkIfDataImported()
            if hasImported {
                print("✅ Operational data already loaded")
                return
            }
            
            print("🔄 Loading operational data...")
            await MainActor.run {
                csvImportProgress = 0.1
            }
            
            let (imported, errors) = try await operationalManager.importRealWorldTasks()
            
            await MainActor.run {
                csvImportProgress = 1.0
            }
            
            print("✅ Loaded \(imported) real tasks from operational data")
            
            if !errors.isEmpty {
                print("⚠️ Import errors: \(errors)")
            }
            
        } catch {
            print("❌ Failed to load operational data: \(error)")
            await MainActor.run {
                self.error = error
            }
        }
    }
    
    private func checkIfDataImported() async -> Bool {
        do {
            guard let workerId = NewAuthManager.shared.workerId, !workerId.isEmpty else {
                return false
            }
            
            let allTasks = try await loadTasksForWorker(workerId)
            
            let operationalTasks = allTasks.filter { task in
                !task.assignedWorkerName.isEmpty
            }
            
            let hasMinimumTasks = allTasks.count >= 20
            let hasOperationalPattern = operationalTasks.count > 0
            
            return hasMinimumTasks || hasOperationalPattern
            
        } catch {
            print("❌ Error checking operational data status: \(error)")
            return false
        }
    }
    
    private func setupReactiveBindings() {
        contextEngine.objectWillChange
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                Task {
                    await self?.refreshDashboard()
                }
            }
            .store(in: &cancellables)
    }
    
    func startBackgroundUpdates() {
        refreshTimer = Timer.scheduledTimer(withTimeInterval: 300, repeats: true) { _ in
            Task {
                await self.refreshDashboard()
            }
        }
    }
    
    func stopBackgroundUpdates() {
        refreshTimer?.invalidate()
        refreshTimer = nil
    }
    
    deinit {
        refreshTimer?.invalidate()
        cancellables.removeAll()
    }
}

// MARK: - Supporting Types (Unique names to avoid conflicts)

struct DashboardData {
    let workerId: String
    let assignedBuildings: [FrancoSphere.NamedCoordinate]
    let todaysTasks: [ContextualTask]
    let taskProgress: WDITaskProgress
    let lastUpdated: Date
}

struct WDITaskProgress {
    let completed: Int
    let total: Int
    let remaining: Int
    let percentage: Double
    let overdueTasks: Int
}

struct WDITaskEvidence {
    let photos: [Data]
    let timestamp: Date
    let location: CLLocation?
    let notes: String?
}

extension WorkerDashboardIntegration {
    
    static func initialize() async {
        await shared.ensureOperationalDataLoaded()
    }
    
    static func loadForWorker(_ workerId: String) async -> WorkerDashboardIntegration {
        await shared.loadDashboardData(for: workerId)
        shared.startBackgroundUpdates()
        return shared
    }
}
INNER_EOF

echo "   ✅ WorkerDashboardIntegration.swift fixed (final version)"

# Step 5: Fix Models/FrancoSphereModels.swift - Remove duplicate Worker declaration
echo "🔧 Step 5: Fixing FrancoSphereModels.swift duplicate Worker..."

if [ -f "Models/FrancoSphereModels.swift" ]; then
    # Create backup
    cp "Models/FrancoSphereModels.swift" "Models/FrancoSphereModels.swift.backup"
    
    # Remove duplicate Worker struct (keep the first one, remove around line 2160)
    sed -i '' '2150,2200{/struct Worker/,/^}/d;}' "Models/FrancoSphereModels.swift"
    
    # Fix property visibility issues by making internal types public
    sed -i '' 's/public var.*: WorkerShift/public var currentShift: WorkerShiftPublic/g' "Models/FrancoSphereModels.swift"
    sed -i '' 's/public init.*WorkerShift/public init(currentShift: WorkerShiftPublic)/g' "Models/FrancoSphereModels.swift"
    
    echo "   ✅ Fixed duplicate Worker declaration and visibility issues"
fi

# Step 6: Update all WorkerManager references to WorkerService
echo "🔄 Step 6: Updating WorkerManager references to WorkerService..."

find . -name "*.swift" -type f -exec grep -l "WorkerManager" {} \; | while read file; do
    echo "   📝 Updating $file"
    sed -i '' 's/WorkerManager\.shared/WorkerService.shared/g' "$file"
    sed -i '' 's/WorkerManager(/WorkerService(/g' "$file"
    sed -i '' 's/: WorkerManager/: WorkerService/g' "$file"
done

echo "   ✅ All WorkerManager references updated to WorkerService"

# Step 7: Add missing imports where needed
echo "📥 Step 7: Adding missing imports..."

# Add Foundation import to files that use MaintenanceTask
find . -name "*.swift" -type f -exec grep -l "MaintenanceTask" {} \; | while read file; do
    if ! grep -q "import Foundation" "$file"; then
        sed -i '' '1i\
import Foundation
' "$file"
        echo "   📝 Added Foundation import to $file"
    fi
done

echo "   ✅ Missing imports added"

# Step 8: Test compilation
echo "🔨 Step 8: Testing compilation..."

BUILD_OUTPUT=$(xcodebuild clean build -project FrancoSphere.xcodeproj -scheme FrancoSphere -destination 'platform=iOS Simulator,name=iPhone 15' 2>&1)
ERROR_COUNT=$(echo "$BUILD_OUTPUT" | grep -c "error:" || echo "0")

echo ""
echo "📊 Build Results: $ERROR_COUNT errors"

if [ "$ERROR_COUNT" -eq 0 ]; then
    echo ""
    echo "🎉 SUCCESS: All missing type errors fixed!"
    echo "✅ MaintenanceTask, TaskCategory, TaskUrgency, TaskRecurrence defined"
    echo "✅ WeatherManager created"
    echo "✅ TSTaskProgress conflicts resolved"
    echo "✅ Worker redeclaration fixed"
    echo "✅ WorkerManager references updated to WorkerService"
    echo "✅ All imports added"
else
    echo ""
    echo "⚠️ Still has $ERROR_COUNT compilation errors"
    echo "Top 10 remaining errors:"
    echo "$BUILD_OUTPUT" | grep "error:" | head -10
    
    # Show specific file error counts
    echo ""
    echo "📊 Error breakdown by file:"
    echo "$BUILD_OUTPUT" | grep "error:" | cut -d: -f1 | sort | uniq -c | sort -nr | head -5
fi

echo ""
echo "🔧 Type definition fix complete!"
echo "📁 New files created:"
echo "   - Models/TaskTypes.swift (MaintenanceTask, TaskCategory, TaskUrgency, TaskRecurrence)"
echo "   - Managers/WeatherManager.swift"
echo "📁 Files fixed:"
echo "   - Services/WorkerDashboardIntegration.swift"
echo "   - Models/FrancoSphereModels.swift"
echo "   - All files with WorkerManager references"
