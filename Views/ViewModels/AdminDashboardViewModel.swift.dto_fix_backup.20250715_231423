//
//  AdminDashboardViewModel.swift
//  FrancoSphere v6.0
//
//  ✅ FIXED: SwiftUI import added for Color type
//  ✅ FIXED: Using existing CoreTypes.IntelligenceInsight (no duplicate BuildingIntelligenceDTO)
//  ✅ FIXED: Service reference patterns using .shared consistently
//  ✅ ALIGNED: With current implementation phase
//

import Foundation
import SwiftUI
import Combine

@MainActor
class AdminDashboardViewModel: ObservableObject {
    
    // MARK: - Published Properties for Admin UI
    @Published var buildings: [NamedCoordinate] = []
    @Published var activeWorkers: [WorkerProfile] = []
    @Published var ongoingTasks: [ContextualTask] = []
    @Published var buildingMetrics: [String: CoreTypes.BuildingMetrics] = [:]
    @Published var portfolioInsights: [CoreTypes.IntelligenceInsight] = []
    
    // MARK: - Building Intelligence Panel (Using existing CoreTypes)
    @Published var selectedBuildingInsights: [CoreTypes.IntelligenceInsight] = []
    @Published var selectedBuildingId: String?
    @Published var isLoadingIntelligence = false
    
    // MARK: - Loading States
    @Published var isLoading = false
    @Published var isLoadingInsights = false
    @Published var errorMessage: String?
    @Published var lastUpdateTime: Date?
    
    // MARK: - Services (Using .shared pattern consistently)
    private let buildingService = BuildingService.shared
    private let taskService = TaskService.shared
    private let workerService = WorkerService.shared
    private let buildingMetricsService = BuildingMetricsService.shared
    private let intelligenceService = IntelligenceService.shared
    
    // MARK: - Real-time Subscriptions
    private var cancellables = Set<AnyCancellable>()
    private var refreshTimer: Timer?
    
    init() {
        setupAutoRefresh()
    }
    
    deinit {
        refreshTimer?.invalidate()
    }
    
    // MARK: - Setup Methods
    
    private func setupAutoRefresh() {
        refreshTimer = Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { [weak self] _ in
            Task { @MainActor in
                await self?.refreshDashboardData()
            }
        }
    }
    
    // MARK: - Data Loading Methods
    
    /// Loads all dashboard data using existing service methods
    func loadDashboardData() async {
        isLoading = true
        errorMessage = nil
        
        do {
            // Use actual service methods that exist
            async let buildingsResult = try buildingService.getAllBuildings()
            async let workersResult = try workerService.getAllActiveWorkers()
            async let tasksResult = try taskService.getAllTasks()
            
            let (buildings, workers, tasks) = try await (buildingsResult, workersResult, tasksResult)
            
            self.buildings = buildings
            self.activeWorkers = workers
            self.ongoingTasks = tasks
            
            // Load building metrics for each building
            await loadBuildingMetrics()
            
            self.lastUpdateTime = Date()
            print("✅ Admin dashboard loaded: \(buildings.count) buildings, \(workers.count) workers, \(tasks.count) tasks")
            
        } catch {
            errorMessage = "Failed to load dashboard data: \(error.localizedDescription)"
            print("❌ Admin dashboard load failed: \(error)")
        }
        
        isLoading = false
    }
    
    /// Loads building metrics for all buildings
    private func loadBuildingMetrics() async {
        var metrics: [String: CoreTypes.BuildingMetrics] = [:]
        
        for building in buildings {
            do {
                let buildingMetrics = try await buildingMetricsService.calculateMetrics(for: building.id)
                metrics[building.id] = buildingMetrics
            } catch {
                print("⚠️ Failed to load metrics for building \(building.id): \(error)")
            }
        }
        
        self.buildingMetrics = metrics
    }
    
    /// Loads portfolio-wide intelligence insights
    func loadPortfolioInsights() async {
        isLoadingInsights = true
        
        do {
            let insights = try await intelligenceService.generatePortfolioInsights()
            self.portfolioInsights = insights
            self.isLoadingInsights = false
            
            print("✅ Portfolio insights loaded: \(insights.count) insights")
            
        } catch {
            self.portfolioInsights = []
            self.isLoadingInsights = false
            print("⚠️ Failed to load portfolio insights: \(error)")
        }
    }
    
    // MARK: - Building Intelligence Methods
    
    /// Fetches detailed intelligence for a specific building
    func fetchBuildingIntelligence(for buildingId: String) async {
        guard !buildingId.isEmpty else {
            print("⚠️ Invalid building ID provided")
            return
        }
        
        isLoadingIntelligence = true
        selectedBuildingInsights = []
        selectedBuildingId = buildingId
        
        do {
            let insights = try await intelligenceService.generateBuildingInsights(for: buildingId)
            
            self.selectedBuildingInsights = insights
            self.isLoadingIntelligence = false
            
            print("✅ Intelligence loaded for building \(buildingId): \(insights.count) insights")
            
        } catch {
            self.isLoadingIntelligence = false
            self.errorMessage = "Failed to fetch intelligence: \(error.localizedDescription)"
            print("🚨 Failed to fetch intelligence for building \(buildingId): \(error)")
        }
    }
    
    /// Clears the selected building intelligence
    func clearBuildingIntelligence() {
        selectedBuildingInsights = []
        selectedBuildingId = nil
        errorMessage = nil
        print("🧹 Cleared selected building intelligence")
    }
    
    // MARK: - Real-time Update Methods
    
    /// Refreshes all dashboard data
    func refreshDashboardData() async {
        guard !isLoading else { return }
        
        print("🔄 Refreshing admin dashboard data...")
        await loadDashboardData()
    }
    
    /// Refreshes metrics for a specific building
    func refreshBuildingMetrics(for buildingId: String) async {
        do {
            let metrics = try await buildingMetricsService.calculateMetrics(for: buildingId)
            buildingMetrics[buildingId] = metrics
            print("✅ Refreshed metrics for building \(buildingId)")
        } catch {
            print("❌ Failed to refresh metrics for building \(buildingId): \(error)")
        }
    }
    
    // MARK: - Helper Methods
    
    /// Get building metrics for a specific building
    func getBuildingMetrics(for buildingId: String) -> CoreTypes.BuildingMetrics? {
        return buildingMetrics[buildingId]
    }
    
    /// Get insights for a specific building
    func getInsightsForBuilding(_ buildingId: String) -> [CoreTypes.IntelligenceInsight] {
        return portfolioInsights.filter { insight in
            insight.affectedBuildings?.contains(buildingId) == true ||
            insight.category == .building
        }
    }
    
    /// Calculate portfolio summary metrics
    func getPortfolioSummary() -> PortfolioSummary {
        let totalBuildings = buildings.count
        let totalWorkers = activeWorkers.count
        let totalTasks = ongoingTasks.count
        let completedTasks = ongoingTasks.filter { $0.isCompleted }.count
        
        let averageCompletion = buildingMetrics.values.isEmpty ? 0 : 
            buildingMetrics.values.reduce(0) { $0 + $1.completionRate } / Double(buildingMetrics.count)
        
        let criticalInsights = portfolioInsights.filter { $0.priority == .critical }.count
        
        return PortfolioSummary(
            totalBuildings: totalBuildings,
            totalWorkers: totalWorkers,
            totalTasks: totalTasks,
            completedTasks: completedTasks,
            averageCompletion: averageCompletion,
            criticalInsights: criticalInsights
        )
    }
}

// MARK: - Supporting Types (Using existing patterns)

struct PortfolioSummary {
    let totalBuildings: Int
    let totalWorkers: Int
    let totalTasks: Int
    let completedTasks: Int
    let averageCompletion: Double
    let criticalInsights: Int
}

enum EfficiencyStatus {
    case excellent
    case good
    case needsImprovement
    
    var color: Color {
        switch self {
        case .excellent: return .green
        case .good: return .blue
        case .needsImprovement: return .orange
        }
    }
}
